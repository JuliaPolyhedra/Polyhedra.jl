<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimization · Polyhedra</title><meta name="title" content="Optimization · Polyhedra"/><meta property="og:title" content="Optimization · Polyhedra"/><meta property="twitter:title" content="Optimization · Polyhedra"/><meta name="description" content="Documentation for Polyhedra."/><meta property="og:description" content="Documentation for Polyhedra."/><meta property="twitter:description" content="Documentation for Polyhedra."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Polyhedra</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../representation/">Representation</a></li><li><a class="tocitem" href="../polyhedron/">Polyhedron</a></li><li><a class="tocitem" href="../plot/">Plot</a></li><li><a class="tocitem" href="../redundancy/">Containment/Redundancy</a></li><li><a class="tocitem" href="../projection/">Projection/Elimination</a></li><li class="is-active"><a class="tocitem" href>Optimization</a><ul class="internal"><li><a class="tocitem" href="#Using-a-polyhedron-for-in-an-optimization-model"><span>Using a polyhedron for in an optimization model</span></a></li><li><a class="tocitem" href="#Creating-a-polyhedron-from-the-feasible-set-of-a-JuMP-model"><span>Creating a polyhedron from the feasible set of a JuMP model</span></a></li></ul></li><li><a class="tocitem" href="../utilities/">Utilities</a></li><li><a class="tocitem" href="../internal/">Internal</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/Convex hull and intersection/">Convex hull and intersection</a></li><li><a class="tocitem" href="../generated/Extended Formulation/">Extended Formulation</a></li><li><a class="tocitem" href="../generated/Minimal Robust Positively Invariant Set/">Minimal Robust Positively Invariant Set</a></li><li><a class="tocitem" href="../generated/Convex hull of a set of points/">Convex hull of a set of points</a></li><li><a class="tocitem" href="../generated/Projection of H-representation/">Projection of H-representation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Optimization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optimization</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPolyhedra/Polyhedra.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPolyhedra/Polyhedra.jl/blob/master/docs/src/optimization.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Optimization"><a class="docs-heading-anchor" href="#Optimization">Optimization</a><a id="Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization" title="Permalink"></a></h1><p>A polyhedron can represents the feasible set of an optimization program. The program is infeasible when the polyhedron is empty.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isempty" href="#Base.isempty"><code>Base.isempty</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isempty(p::Rep, solver=Polyhedra.linear_objective_solver(p))</code></pre><p>Check whether the polyhedron <code>p</code> is empty by using the solver <code>solver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPolyhedra/Polyhedra.jl/blob/16883685ad9317936bb5dbb1c8b69f1ba687e0e0/src/opt.jl#L147-L151">source</a></section></article><p>If the V-representation of the polyhedron has been computed, it can be used to solve the linear program.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Polyhedra.VRepOptimizer" href="#Polyhedra.VRepOptimizer"><code>Polyhedra.VRepOptimizer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VRepOptimizer{T} &lt;: AbstractPolyhedraOptimizer{T}</code></pre><p>Linear Programming solver using the V-representation of the feasible set to find the optimal solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPolyhedra/Polyhedra.jl/blob/16883685ad9317936bb5dbb1c8b69f1ba687e0e0/src/vrep_optimizer.jl#L3-L8">source</a></section></article><p>Otherwise, any programming solver implementing the <a href="https://github.com/jump-dev/MathOptInterface.jl">MathOptInterface</a> interface can be used. See <a href="http://jump.dev/JuMP.jl/dev/installation/#Getting-Solvers-1">here</a> for a list of available solvers.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Polyhedra.default_solver" href="#Polyhedra.default_solver"><code>Polyhedra.default_solver</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">default_solver(p::Rep)</code></pre><p>Returns a default linear programming solver for the polyhedron <code>p</code> (e.g. CDD has an internal solver which is used by default).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPolyhedra/Polyhedra.jl/blob/16883685ad9317936bb5dbb1c8b69f1ba687e0e0/src/default.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Polyhedra.linear_objective_solver" href="#Polyhedra.linear_objective_solver"><code>Polyhedra.linear_objective_solver</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linear_objective_solver(p::Rep, solver=default_solver(p))</code></pre><p>Return the solver to use for optimizing a linear objective over the polyhedron <code>p</code>, i.e.</p><pre><code class="language-julia hljs">model = Model(solver)
x = @variable(model, [1:fulldim(p)])
@constraint(model, x in p)
@objective(model, c ⋅ x)</code></pre><p>for some vector <code>c</code>.</p><p>By default, if the V-representation of <code>p</code> has been computed, it returns <code>VRepOptimizer()</code>, otherwise, it returns <code>solver</code>.</p><p>If the problem has constraints different to <code>x in p</code>, use <code>default_solver(p)</code> instead as the fact that the V-representation of <code>p</code> has been computed does not help.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPolyhedra/Polyhedra.jl/blob/16883685ad9317936bb5dbb1c8b69f1ba687e0e0/src/default.jl#L87-L104">source</a></section></article><h2 id="Using-a-polyhedron-for-in-an-optimization-model"><a class="docs-heading-anchor" href="#Using-a-polyhedron-for-in-an-optimization-model">Using a polyhedron for in an optimization model</a><a id="Using-a-polyhedron-for-in-an-optimization-model-1"></a><a class="docs-heading-anchor-permalink" href="#Using-a-polyhedron-for-in-an-optimization-model" title="Permalink"></a></h2><p>A polyhedron or representation can be used in the constraint of a JuMP model. For instance, consider the 1-simplex:</p><pre><code class="language-julia-repl hljs">julia&gt; using Polyhedra

julia&gt; simplex = HalfSpace([-1, 0], 0) ∩ HalfSpace([0, -1], 0) ∩ HyperPlane([1, 1], 1)
H-representation Polyhedra.Intersection{Int64, Vector{Int64}, Int64}:
1-element iterator of HyperPlane{Int64, Vector{Int64}}:
 HyperPlane([1, 1], 1),
2-element iterator of HalfSpace{Int64, Vector{Int64}}:
 HalfSpace([-1, 0], 0)
 HalfSpace([0, -1], 0)</code></pre><p>and the following JuMP model with two variables</p><pre><code class="language-julia-repl hljs">julia&gt; using JuMP

julia&gt; model = Model()
A JuMP Model
├ solver: none
├ objective_sense: FEASIBILITY_SENSE
├ num_variables: 0
├ num_constraints: 0
└ Names registered in the model: none

julia&gt; @variable(model, λ[1:2])
2-element Vector{VariableRef}:
 λ[1]
 λ[2]</code></pre><p>The variables can be constrained to belong to the simplex as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; @constraint(model, λ in simplex)
[λ[1], λ[2]] ∈ Polyhedra.PolyhedraOptSet{Int64, Polyhedra.Intersection{Int64, Vector{Int64}, Int64}}(HyperPlane([1, 1], 1) ∩ HalfSpace([-1, 0], 0) ∩ HalfSpace([0, -1], 0))</code></pre><p>but a vector of affine or quadratic expressions can also be constrained to belong to the simplex:</p><pre><code class="language-julia-repl hljs">julia&gt; A = [1  1
            1 -1]
2×2 Matrix{Int64}:
 1   1
 1  -1

julia&gt; @constraint(model, A * λ in simplex)
[λ[1] + λ[2], λ[1] - λ[2]] ∈ Polyhedra.PolyhedraOptSet{Int64, Polyhedra.Intersection{Int64, Vector{Int64}, Int64}}(HyperPlane([1, 1], 1) ∩ HalfSpace([-1, 0], 0) ∩ HalfSpace([0, -1], 0))</code></pre><p>We can verify that the model contains both constraints:</p><pre><code class="language-julia hljs">julia&gt; model
A JuMP Model
Feasibility problem with:
Variables: 2
`Array{JuMP.VariableRef,1}`-in-`Polyhedra.PolyhedraOptSet{Int64,Polyhedra.Intersection{Int64,Array{Int64,1},Int64}}`: 1 constraint
`Array{JuMP.GenericAffExpr{Float64,JuMP.VariableRef},1}`-in-`Polyhedra.PolyhedraOptSet{Int64,Polyhedra.Intersection{Int64,Array{Int64,1},Int64}}`: 1 constraint
Model mode: AUTOMATIC
CachingOptimizer state: NO_OPTIMIZER
Solver name: No optimizer attached.
Names registered in the model: λ</code></pre><p>When the model is solved, the constraint is automatically transformed into appropriate constraints if the optimizer does not support consraints with the set <code>Polyhedra.PolyhedraOptSet</code>.</p><pre><code class="language-julia hljs">julia&gt; import GLPK

julia&gt; set_optimizer(model, GLPK.Optimizer)

julia&gt; optimize!(model)

julia&gt; termination_status(model)
OPTIMAL::TerminationStatusCode = 1

julia&gt; value.(λ)
2-element Array{Float64,1}:
 0.5
 0.5</code></pre><p>For instance, GLPK, does not support <code>Polyhedra.PolyhedraOptSet</code> constraints but supports <code>MOI.EqualTo{Float64}</code> and <code>MOI.LessThan{Float64}</code>. The polyhedral constraints are therefore bridged into several <code>MOI.EqualTo{Float64}</code> and <code>MOI.LessThan{Float64}</code> constraints using the following <a href="http://jump.dev/MathOptInterface.jl/stable/apimanual/#Constraint-bridges-1">constraint bridge</a>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Polyhedra.PolyhedraToLPBridge" href="#Polyhedra.PolyhedraToLPBridge"><code>Polyhedra.PolyhedraToLPBridge</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PolyhedraToLPBridge{T}</code></pre><p>The <code>PolyhedraToLPBridge</code> converts a constraint <code>VF</code>-in-<code>PolyhedraOptSet</code> into the constraints <code>F</code>-in-<code>EqualTo</code> for the hyperplanes and <code>F</code>-to-<code>LessThan</code> for halfspaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPolyhedra/Polyhedra.jl/blob/16883685ad9317936bb5dbb1c8b69f1ba687e0e0/src/polyhedra_to_lp_bridge.jl#L1-L7">source</a></section></article><p>See <a href="https://github.com/JuliaPolyhedra/Polyhedra.jl/blob/master/examples/Polyhedral%20Function.ipynb">Polyhedral Function</a> for an example notebook.</p><h2 id="Creating-a-polyhedron-from-the-feasible-set-of-a-JuMP-model"><a class="docs-heading-anchor" href="#Creating-a-polyhedron-from-the-feasible-set-of-a-JuMP-model">Creating a polyhedron from the feasible set of a JuMP model</a><a id="Creating-a-polyhedron-from-the-feasible-set-of-a-JuMP-model-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-polyhedron-from-the-feasible-set-of-a-JuMP-model" title="Permalink"></a></h2><p>A typical application of polyhedral computation is the computation of the set of extreme points and rays of the feasible set of an optimization problem. This comes from the fact that given a minimization of a concave function (or maximization of a convex function) on a convex feasible set (e.g. Linear Programming), we are either in the following three situations:</p><ul><li>The feasible set is empty, i.e. the problem is infeasible.</li><li>An extreme ray is optimal, i.e. the problem is unbounded (or it may also be bounded if the objective is constant along the ray).</li><li>An extreme point is optimal.</li></ul><p>A JuMP model is treated by <code>polyhedron</code> just like any H-representation. For example, the hypercube of dimension <code>n</code> can be created as follows</p><pre><code class="language-julia hljs">using JuMP, Polyhedra
model = Model()
@variable(model, 0 ≤ x[1:2] ≤ 1)
h = hrep(model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">H-representation LPHRep{Float64}:
4-element iterator of HalfSpace{Float64, SparseArrays.SparseVector{Float64, Int64}}:
 HalfSpace(sparsevec([1], [-1.0], 2), -0.0)
 HalfSpace(sparsevec([2], [-1.0], 2), -0.0)
 HalfSpace(sparsevec([1], [1.0], 2), 1.0)
 HalfSpace(sparsevec([2], [1.0], 2), 1.0)</code></pre><p>The name of the variables for each dimension can be recovered as follows</p><pre><code class="language-julia hljs">dimension_names(h)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{String}:
 &quot;x[1]&quot;
 &quot;x[2]&quot;</code></pre><p>Note that the names of the JuMP variables are lost in the conversion to a polyhedron that does not support names, e.g.,</p><pre><code class="language-julia hljs">poly = polyhedron(model, CDDLib.Library(:exact))</code></pre><p>However, the ordering of the dimension of the polyhedron is guaranteed to correspond to the order of the JuMP variables as listed by <code>all_variables</code>:</p><pre><code class="language-julia hljs">all_variables(model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{JuMP.VariableRef}:
 x[1]
 x[2]</code></pre><p>So <code>all_variables(model)[i]</code> provides the JuMP variable corresponding to the <code>i</code>th dimension. The reverse mapping can be constructed as follows:</p><pre><code class="language-julia hljs">Dict(v =&gt; i for (i, v) in enumerate(all_variables(model)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{JuMP.VariableRef, Int64} with 2 entries:
  x[2] =&gt; 2
  x[1] =&gt; 1</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../projection/">« Projection/Elimination</a><a class="docs-footer-nextpage" href="../utilities/">Utilities »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 15 January 2025 14:55">Wednesday 15 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
