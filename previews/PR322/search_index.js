var documenterSearchIndex = {"docs":
[{"location":"optimization/#Optimization","page":"Optimization","title":"Optimization","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"A polyhedron can represents the feasible set of an optimization program. The program is infeasible when the polyhedron is empty.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"isempty","category":"page"},{"location":"optimization/#Base.isempty","page":"Optimization","title":"Base.isempty","text":"isempty(p::Rep, solver=Polyhedra.linear_objective_solver(p))\n\nCheck whether the polyhedron p is empty by using the solver solver.\n\n\n\n\n\n","category":"function"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"If the V-representation of the polyhedron has been computed, it can be used to solve the linear program.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"VRepOptimizer","category":"page"},{"location":"optimization/#Polyhedra.VRepOptimizer","page":"Optimization","title":"Polyhedra.VRepOptimizer","text":"VRepOptimizer{T} <: AbstractPolyhedraOptimizer{T}\n\nLinear Programming solver using the V-representation of the feasible set to find the optimal solution.\n\n\n\n\n\n","category":"type"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"Otherwise, any programming solver implementing the MathOptInterface interface can be used. See here for a list of available solvers.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"Polyhedra.default_solver\nPolyhedra.linear_objective_solver","category":"page"},{"location":"optimization/#Polyhedra.default_solver","page":"Optimization","title":"Polyhedra.default_solver","text":"default_solver(p::Rep)\n\nReturns a default linear programming solver for the polyhedron p (e.g. CDD has an internal solver which is used by default).\n\n\n\n\n\n","category":"function"},{"location":"optimization/#Polyhedra.linear_objective_solver","page":"Optimization","title":"Polyhedra.linear_objective_solver","text":"linear_objective_solver(p::Rep, solver=default_solver(p))\n\nReturn the solver to use for optimizing a linear objective over the polyhedron p, i.e.\n\nmodel = Model(solver)\nx = @variable(model, [1:fulldim(p)])\n@constraint(model, x in p)\n@objective(model, c ⋅ x)\n\nfor some vector c.\n\nBy default, if the V-representation of p has been computed, it returns VRepOptimizer(), otherwise, it returns solver.\n\nIf the problem has constraints different to x in p, use default_solver(p) instead as the fact that the V-representation of p has been computed does not help.\n\n\n\n\n\n","category":"function"},{"location":"optimization/#Using-a-polyhedron-for-in-an-optimization-model","page":"Optimization","title":"Using a polyhedron for in an optimization model","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"A polyhedron or representation can be used in the constraint of a JuMP model. For instance, consider the 1-simplex:","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"julia> using Polyhedra\n\njulia> simplex = HalfSpace([-1, 0], 0) ∩ HalfSpace([0, -1], 0) ∩ HyperPlane([1, 1], 1)\nH-representation Polyhedra.Intersection{Int64, Vector{Int64}, Int64}:\n1-element iterator of HyperPlane{Int64, Vector{Int64}}:\n HyperPlane([1, 1], 1),\n2-element iterator of HalfSpace{Int64, Vector{Int64}}:\n HalfSpace([-1, 0], 0)\n HalfSpace([0, -1], 0)","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"and the following JuMP model with two variables","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"julia> using JuMP\n\njulia> model = Model()\nA JuMP Model\nFeasibility problem with:\nVariables: 0\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\n\njulia> @variable(model, λ[1:2])\n2-element Vector{VariableRef}:\n λ[1]\n λ[2]","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"The variables can be constrained to belong to the simplex as follows:","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"julia> @constraint(model, λ in simplex)\n[λ[1], λ[2]] ∈ Polyhedra.PolyhedraOptSet{Int64, Polyhedra.Intersection{Int64, Vector{Int64}, Int64}}(HyperPlane([1, 1], 1) ∩ HalfSpace([-1, 0], 0) ∩ HalfSpace([0, -1], 0))","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"but a vector of affine or quadratic expressions can also be constrained to belong to the simplex:","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"julia> A = [1  1\n            1 -1]\n2×2 Matrix{Int64}:\n 1   1\n 1  -1\n\njulia> @constraint(model, A * λ in simplex)\n[λ[1] + λ[2], λ[1] - λ[2]] ∈ Polyhedra.PolyhedraOptSet{Int64, Polyhedra.Intersection{Int64, Vector{Int64}, Int64}}(HyperPlane([1, 1], 1) ∩ HalfSpace([-1, 0], 0) ∩ HalfSpace([0, -1], 0))","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"We can verify that the model contains both constraints:","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"julia> model\nA JuMP Model\nFeasibility problem with:\nVariables: 2\n`Array{JuMP.VariableRef,1}`-in-`Polyhedra.PolyhedraOptSet{Int64,Polyhedra.Intersection{Int64,Array{Int64,1},Int64}}`: 1 constraint\n`Array{JuMP.GenericAffExpr{Float64,JuMP.VariableRef},1}`-in-`Polyhedra.PolyhedraOptSet{Int64,Polyhedra.Intersection{Int64,Array{Int64,1},Int64}}`: 1 constraint\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\nNames registered in the model: λ","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"When the model is solved, the constraint is automatically transformed into appropriate constraints if the optimizer does not support consraints with the set Polyhedra.PolyhedraOptSet.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"julia> import GLPK\n\njulia> set_optimizer(model, GLPK.Optimizer)\n\njulia> optimize!(model)\n\njulia> termination_status(model)\nOPTIMAL::TerminationStatusCode = 1\n\njulia> value.(λ)\n2-element Array{Float64,1}:\n 0.5\n 0.5","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"For instance, GLPK, does not support Polyhedra.PolyhedraOptSet constraints but supports MOI.EqualTo{Float64} and MOI.LessThan{Float64}. The polyhedral constraints are therefore bridged into several MOI.EqualTo{Float64} and MOI.LessThan{Float64} constraints using the following constraint bridge:","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"Polyhedra.PolyhedraToLPBridge","category":"page"},{"location":"optimization/#Polyhedra.PolyhedraToLPBridge","page":"Optimization","title":"Polyhedra.PolyhedraToLPBridge","text":"PolyhedraToLPBridge{T}\n\nThe PolyhedraToLPBridge converts a constraint VF-in-PolyhedraOptSet into the constraints F-in-EqualTo for the hyperplanes and F-to-LessThan for halfspaces.\n\n\n\n\n\n","category":"type"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"See Polyhedral Function for an example notebook.","category":"page"},{"location":"optimization/#Creating-a-polyhedron-from-the-feasible-set-of-a-JuMP-model","page":"Optimization","title":"Creating a polyhedron from the feasible set of a JuMP model","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"A typical application of polyhedral computation is the computation of the set of extreme points and rays of the feasible set of an optimization problem. This comes from the fact that given a minimization of a concave function (or maximization of a convex function) on a convex feasible set (e.g. Linear Programming), we are either in the following three situations:","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"The feasible set is empty, i.e. the problem is infeasible.\nAn extreme ray is optimal, i.e. the problem is unbounded (or it may also be bounded if the objective is constant along the ray).\nAn extreme point is optimal.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"A JuMP model is treated by polyhedron just like any H-representation. For example, the hypercube of dimension n can be created as follows","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"m = Model()\n@variable(m, 0 ≤ x[1:n] ≤ 1)\n\npoly = polyhedron(m, CDDLib.Library(:exact))","category":"page"},{"location":"polyhedron/#Polyhedron","page":"Polyhedron","title":"Polyhedron","text":"","category":"section"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"As seen in the previous section, a polyhedron can be described in 2 ways: either using the H-representation (intersection of halfspaces) or the V-representation (convex hull of points and rays). The problem of computing the H-representation from the V-representation (or vice versa) is called the representation conversion problem. It can be solved by the Double-Description method","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"doubledescription","category":"page"},{"location":"polyhedron/#Polyhedra.doubledescription","page":"Polyhedron","title":"Polyhedra.doubledescription","text":"doubledescription(h::HRepresentation)\n\nComputes the V-representation of the polyhedron represented by h using the Double-Description algorithm [MRTT53, FP96]. It maintains a list of the points, rays and lines that are in the resulting representation and in the hyperplane corresponding to each halfspace and then add their intersection for each halfspace with Polyhedra.add_intersection!. The resulting V-representation has no redundancy.\n\ndoubledescription(V::VRepresentation)\n\nComputes the H-representation of the polyhedron represented by v using the Double-Description algorithm [MRTT53, FP96]. Currently, this fallbacks to lifting it to the V-representation of a cone by homogenization, interpreting it as the H-representation of the dual cone so that it can rely on doubledescription(::HRepresentation).\n\n[MRTT53] Motzkin, T. S., Raiffa, H., Thompson, G. L. and Thrall, R. M. The double description method Contribution to the Theory of Games, Princeton University Press, 1953\n\n[FP96] Fukuda, K. and Prodon, A. Double description method revisited Combinatorics and computer science, Springer, 1996, 91-111\n\n\n\n\n\n","category":"function"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"However, other methods exist such as the reverse search implemented by LRS and the quick hull algorithm implemented by qhull.","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"This motivates the creation of a type representing polyhedra, transparently handling the conversion from H-representation to V-representation when needed for some operation. Just like the abstract type AbstractArray{N,T} represents an N-dimensional array with elements of type T, the abstract type Polyhedron{N,T} represents an N-dimensional polyhedron with elements of coefficient type T.","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"There is typically one concrete subtype of Polyhedron by library. For instance, the CDD library defines CDDLib.Polyhedron and the LRS library defines LRSLib.Polyhedron. It must be said that the type T is not necessarily how the elements are stored internally by the library but the polyhedron will behave just like it is stored that way. For instance, when retreiving an H-(or V-)representation, the representation will be of type T. Therefore using Int for T may result in InexactError. For this reason, by default, the type T chosen is not a subtype of Integer.","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"A polyhedron can be created from a representation and a library using the polyhedron function.","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"polyhedron","category":"page"},{"location":"polyhedron/#Polyhedra.polyhedron","page":"Polyhedron","title":"Polyhedra.polyhedron","text":"polyhedron(rep::Representation{T})\n\nCreates a polyhedron from the representation rep using the default library included in the Polyhedra package.\n\n\n\n\n\n","category":"function"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"To illustrate the usage of the polyhedron function, consider the following representations:","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"hr = HalfSpace([1, 1], 1) ∩ HalfSpace([1, -1], 0) ∩ HalfSpace([-1, 0], 0)\nvre = convexhull([0, 0], [0, 1], [1//2, 1//2])\nvrf = convexhull([0, 0], [0, 1], [1/2, 1/2])","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"One can use the CDD library, to create an instance of a concrete subtype of Polyhedron as follows:","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"julia> using CDDLib\njulia> polyf = polyhedron(hr, CDDLib.Library())\njulia> typeof(polyhf)\nCDDLib.CDDLib.Polyhedron{2,Float64}","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"We see that the library has choosen to deal with floating point arithmetic. This decision does not depend on the type of hr but only on the instance of CDDLib.Library given. CDDLib.Library creates CDDLib.Polyhedron of type either Float64 or Rational{BigInt}. One can choose the first one using CDDLib.Library(:float) and the second one using CDDLib.Library(:exact), by default it is :float.","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"julia> poly = polyhedron(hr, CDDLib.Library(:exact))\njulia> typeof(poly)\nCDDLib.Polyhedron{2,Rational{BigInt}}","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"The first polyhedron polyf can also be created from its V-representation using either of the 4 following lines:","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"julia> polyf = polyhedron(vrf, CDDLib.Library(:float))\njulia> polyf = polyhedron(vrf, CDDLib.Library())\njulia> polyf = polyhedron(vre,  CDDLib.Library(:float))\njulia> polyf = polyhedron(vre,  CDDLib.Library())","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"and poly using either of those lines:","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"julia> poly = polyhedron(vrf, CDDLib.Library(:exact))\njulia> poly = polyhedron(vre, CDDLib.Library(:exact))","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"Of course, creating a representation in floating points with exact arithmetic works here because we have 0.5 which is 0.1 in binary but in general, is not a good idea.","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"julia> Rational{BigInt}(1/2)\n1//2\njulia> Rational{BigInt}(1/3)\n6004799503160661//18014398509481984\njulia> Rational{BigInt}(1/5)\n3602879701896397//18014398509481984","category":"page"},{"location":"polyhedron/#Retrieving-a-representation","page":"Polyhedron","title":"Retrieving a representation","text":"","category":"section"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"One can retrieve an H-representation (resp. V-representation) from a polyhedron using hrep (resp. vrep). The concrete subtype of HRepresentation (resp. VRepresentation) returned is not necessarily the same that the one used to create the polyhedron. As a rule of thumb, it is the representation the closest to the internal representation used by the library.","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"julia> hr = hrep(poly)\njulia> typeof(hr)\nPolyhedra.LiftedHRepresentation{2,Rational{BigInt}}\njulia> hr = MixedMatHRep(hr)\njulia> typeof(hr)\nPolyhedra.MixedMatHRep{2,Rational{BigInt}}\njulia> hr.A\n3x2 Array{Rational{BigInt},2}:\n  1//1   1//1\n  1//1  -1//1\n -1//1   0//1\njulia> hr.b\n3-element Array{Rational{BigInt},1}:\n 1//1\n 0//1\n 0//1\njulia> vr = vrep(poly)\njulia> typeof(vr)\nPolyhedra.LiftedVRepresentation{2,Rational{BigInt}}\njulia> vr = MixedMatVRep(vrep)\njulia> typeof(vr)\nPolyhedra.MixedMatVRep{2,Rational{BigInt}}\njulia> vr.V\n3x2 Array{Rational{BigInt},2}:\n 1//2  1//2\n 0//1  1//1\n 0//1  0//1\n\njulia> vr.R\n0x2 Array{Rational{BigInt},2}","category":"page"},{"location":"polyhedron/#Checking-if-a-representation-has-been-computed","page":"Polyhedron","title":"Checking if a representation has been computed","text":"","category":"section"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"hrepiscomputed\nvrepiscomputed","category":"page"},{"location":"polyhedron/#Polyhedra.hrepiscomputed","page":"Polyhedron","title":"Polyhedra.hrepiscomputed","text":"hrepiscomputed(p::Polyhedron)\n\nReturns whether the H-representation of this polyhedron has been computed.\n\n\n\n\n\n","category":"function"},{"location":"polyhedron/#Polyhedra.vrepiscomputed","page":"Polyhedron","title":"Polyhedra.vrepiscomputed","text":"vrepiscomputed(p::Polyhedron)\n\nReturns whether the V-representation of this polyhedron has been computed.\n\n\n\n\n\n","category":"function"},{"location":"polyhedron/#Incidence","page":"Polyhedron","title":"Incidence","text":"","category":"section"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"Elements can be accessed in a representation or polyhedron using indices and Base.get:","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"Polyhedra.Index\nPolyhedra.Indices","category":"page"},{"location":"polyhedron/#Polyhedra.Index","page":"Polyhedron","title":"Polyhedra.Index","text":"Index{T,ElemT} <: AbstractIndex{T,ElemT}\n\nIndex of an element of type ElemT in a Rep{T}.\n\n\n\n\n\n","category":"type"},{"location":"polyhedron/#Polyhedra.Indices","page":"Polyhedron","title":"Polyhedra.Indices","text":"Indices{T, ElemT, RepT<:Rep{T}}\n\nIterator over the indices of the elements of type ElemT of the field rep.\n\n\n\n\n\n","category":"type"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"The list of indices can be obtained using, e.g., eachindex(points(rep)). For instance, the following prints all points using indices","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"for pi in eachindex(points(rep))\n    @show get(rep, pi)\nend","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"A point p (resp. ray r) is incident to an halfspace langle a x rangle le beta if langle a p rangle = beta (resp. langle a r rangle = beta).","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"incidenthalfspaces\nincidenthalfspaceindices\nincidentpoints\nincidentpointindices\nincidentrays\nincidentrayindices","category":"page"},{"location":"polyhedron/#Polyhedra.incidenthalfspaces","page":"Polyhedron","title":"Polyhedra.incidenthalfspaces","text":"incidenthalfspaces(p::Polyhedron, idx)\n\nReturns the list of halfspaces incident to idx for the polyhedron p.\n\n\n\n\n\n","category":"function"},{"location":"polyhedron/#Polyhedra.incidenthalfspaceindices","page":"Polyhedron","title":"Polyhedra.incidenthalfspaceindices","text":"incidenthalfspaceindices(p::Polyhedron, idx)\n\nReturns the list of the indices of halfspaces incident to idx for the polyhedron p.\n\n\n\n\n\n","category":"function"},{"location":"polyhedron/#Polyhedra.incidentpoints","page":"Polyhedron","title":"Polyhedra.incidentpoints","text":"incidentpoints(p::Polyhedron, idx)\n\nReturns the list of points incident to idx for the polyhedron p.\n\n\n\n\n\n","category":"function"},{"location":"polyhedron/#Polyhedra.incidentpointindices","page":"Polyhedron","title":"Polyhedra.incidentpointindices","text":"incidentpointindices(p::Polyhedron, idx)\n\nReturns the list of the indices of points incident to idx for the polyhedron p.\n\n\n\n\n\n","category":"function"},{"location":"polyhedron/#Polyhedra.incidentrays","page":"Polyhedron","title":"Polyhedra.incidentrays","text":"incidentrays(p::Polyhedron, idx)\n\nReturns the list of rays incident to idx for the polyhedron p.\n\n\n\n\n\n","category":"function"},{"location":"polyhedron/#Polyhedra.incidentrayindices","page":"Polyhedron","title":"Polyhedra.incidentrayindices","text":"incidentrayindices(p::Polyhedron, idx)\n\nReturns the list of the indices of rays incident to idx for the polyhedron p.\n\n\n\n\n\n","category":"function"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"In a polyhedron, all points and rays are incident to all hyperplanes and all halfspaces are incident to all lines. The following methods are therefore redundant, e.g. incidenthyperplanes(p, idx) is equivalent to hyperplanes(p) and incidenthyperplaneindices(p, idx) is equivalent to eachindex(hyperplanes(p)). The methods are hence only defined for consistency.","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"incidenthyperplanes\nincidenthyperplaneindices\nincidentlines\nincidentlineindices","category":"page"},{"location":"polyhedron/#Polyhedra.incidenthyperplanes","page":"Polyhedron","title":"Polyhedra.incidenthyperplanes","text":"incidenthyperplanes(p::Polyhedron, idx)\n\nReturns the list of hyperplanes incident to idx for the polyhedron p.\n\n\n\n\n\n","category":"function"},{"location":"polyhedron/#Polyhedra.incidenthyperplaneindices","page":"Polyhedron","title":"Polyhedra.incidenthyperplaneindices","text":"incidenthyperplaneindices(p::Polyhedron, idx)\n\nReturns the list of the indices of hyperplanes incident to idx for the polyhedron p.\n\n\n\n\n\n","category":"function"},{"location":"polyhedron/#Polyhedra.incidentlines","page":"Polyhedron","title":"Polyhedra.incidentlines","text":"incidentlines(p::Polyhedron, idx)\n\nReturns the list of lines incident to idx for the polyhedron p.\n\n\n\n\n\n","category":"function"},{"location":"polyhedron/#Polyhedra.incidentlineindices","page":"Polyhedron","title":"Polyhedra.incidentlineindices","text":"incidentlineindices(p::Polyhedron, idx)\n\nReturns the list of the indices of lines incident to idx for the polyhedron p.\n\n\n\n\n\n","category":"function"},{"location":"polyhedron/#Default-libraries","page":"Polyhedron","title":"Default libraries","text":"","category":"section"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"The following functions allows to select a default library:","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"default_library\nsimilar_library\nlibrary\ndefault_type","category":"page"},{"location":"polyhedron/#Polyhedra.default_library","page":"Polyhedron","title":"Polyhedra.default_library","text":"default_library(d::FullDim, ::Type{T}) where {T}\n\nReturns the default polyhedral library for d-dimensional polyhedron of coefficient type T.\n\nExamples\n\nTo obtain the default library for 2-dimensional polyhedra of eltype Float64, do default_library(2, Float64).\n\nGiven an StaticArrays.SVector v, to obtain a default library for points of the type of v in a type stable way, do default_library(Polyhedra.FullDim(v), eltype(v)).\n\n\n\n\n\n","category":"function"},{"location":"polyhedron/#Polyhedra.similar_library","page":"Polyhedron","title":"Polyhedra.similar_library","text":"similar_library(lib::Library, d::FullDim, T::Type)\n\nReturns a library that supports polyhedra of full dimension T with coefficient type T. If lib does not support it, this commonly calls default_library(d, T).\n\n\n\n\n\n","category":"function"},{"location":"polyhedron/#Polyhedra.library","page":"Polyhedron","title":"Polyhedra.library","text":"library(p::Polyhedron)\n\nReturns the library used by p.\n\n\n\n\n\n","category":"function"},{"location":"polyhedron/#Polyhedra.default_type","page":"Polyhedron","title":"Polyhedra.default_type","text":"default_type(d::FullDim, ::Type{T}) where {T}\n\nReturns the default polyhedron type for d-dimensional polyhedron of coefficient type T.\n\n\n\n\n\n","category":"function"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"The following libraries serves as fallback:","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"DefaultLibrary\nIntervalLibrary","category":"page"},{"location":"polyhedron/#Polyhedra.DefaultLibrary","page":"Polyhedron","title":"Polyhedra.DefaultLibrary","text":"DefaultLibrary{T}\n\nDefault library for polyhedra of dimension larger than 1 (IntervalLibrary is the default for polyhedra of dimension 1). The library implements the bare minimum and uses the fallback implementation for all operations.\n\n\n\n\n\n","category":"type"},{"location":"polyhedron/#Polyhedra.IntervalLibrary","page":"Polyhedron","title":"Polyhedra.IntervalLibrary","text":"IntervalLibrary{T}\n\nDefault library for polyhedra of dimension 1. Many aspect of polyhedral computation become trivial in one dimension. This library exploits this fact. The library is also used as a fallback for libraries that do not support 1-dimensional polyhedra (e.g. qhull). That is projecting a polyhedron using such library produces a polyhedron using IntervalLibrary.\n\n\n\n\n\n","category":"type"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"The type and library of the polyhedron obtained after applying an operation of several polyhedra (of possibly different type and/or library) is determined by the similar function.","category":"page"},{"location":"polyhedron/","page":"Polyhedron","title":"Polyhedron","text":"similar","category":"page"},{"location":"polyhedron/#Base.similar","page":"Polyhedron","title":"Base.similar","text":"similar(p::Tuple{Vararg{Polyhedra.Rep}}, d::Polyhedra.FullDim, ::Type{T}, it::Polyhedra.It{T}...)\n\nCreates a representation with a type similar to p of a polyhedron of full dimension d, element type T and initialize it with the iterators it. The type of the result will be chosen closer to the type of p[1].\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/#Operations","page":"Utilities","title":"Operations","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"+\n*\n\\\n/\nintersect\nintersect!\nconvexhull\nconvexhull!\ntranslate\npolar","category":"page"},{"location":"utilities/#Base.:+","page":"Utilities","title":"Base.:+","text":"+(p1::VRep, p2::VRep)\n\nMinkowski sum between p1 and p2 using the V-representation. If the V-representation is not computed for p1 or p2, it is computed.\n\n+(p::Rep, el::Union{Line, Ray})\n+(el::Union{Line, Ray}, p::Rep)\n\nSame as p + vrep([el]).\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Base.:*","page":"Utilities","title":"Base.:*","text":"*(p1::Rep, p2::Rep)\n\nCartesian product between the polyhedra p1 and p2.\n\n\n\n\n\n*(P::Union{AbstractMatrix, UniformScaling}, p::VRep)\n\nTransform the polyhedron represented by p into P p by transforming each element of the V-representation (points, symmetric points, rays and lines) x into P x.\n\n\n\n\n\n*(α::Number, p::Rep)\n\nTransform the polyhedron represented by p into alpha p by transforming each element of the V-representation (points, symmetric points, rays and lines) x into alpha x.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Base.:\\","page":"Utilities","title":"Base.:\\","text":"(P::Union{AbstractMatrix, UniformScaling}, p::HRep)\n\nTransform the polyhedron represented by p into P^-1 p by transforming each halfspace langle a x rangle le beta into langle P^top a x rangle le beta and each hyperplane langle a x rangle = beta into langle P^top a x rangle = beta.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Base.:/","page":"Utilities","title":"Base.:/","text":"/(p::HRep, P::Union{AbstractMatrix, UniformScaling})\n\nTransform the polyhedron represented by p into P^-T p by transforming each halfspace langle a x rangle le beta into langle P a x rangle le beta and each hyperplane langle a x rangle = beta into langle P a x rangle = beta.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Base.intersect","page":"Utilities","title":"Base.intersect","text":"intersect(P1::HRep, P2::HRep)\n\nTakes the intersection of P1 and P2  x  x in P_1 x in P_2 . It is very efficient between two H-representations or between two polyhedron for which the H-representation has already been computed. However, if P1 (resp. P2) is a polyhedron for which the H-representation has not been computed yet, it will trigger a representation conversion which is costly. See the Polyhedral Computation FAQ for a discussion on this operation.\n\nThe type of the result will be chosen closer to the type of P1. For instance, if P1 is a polyhedron (resp. H-representation) and P2 is a H-representation (resp. polyhedron), intersect(P1, P2) will be a polyhedron (resp. H-representation). If P1 and P2 are both polyhedra (resp. H-representation), the resulting polyhedron type (resp. H-representation type) will be computed according to the type of P1. The coefficient type however, will be promoted as required taking both the coefficient type of P1 and P2 into account.\n\n\n\n\n\nintersect(v::VRepresentation{T}, h::HRepElement)\n\nCompute the intersection of v with an halfspace or hyperplane h. The method used by default is to keep the V-representation element of v that are in h and add new ones generated as the intersection between the hyperplane defining h and the segment between two adjacent V-representation elements of v that are in either sides of the hyperplane. See Lemma 3 of [FP96] for more detail on the method.\n\n[FP96] Fukuda, K. and Prodon, A. Double description method revisited Combinatorics and computer science, Springer, 1996, 91-111\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Base.intersect!","page":"Utilities","title":"Base.intersect!","text":"intersect!(p::HRep, h::Union{HRepresentation, HRepElement})\n\nSame as intersect except that p is modified to be equal to the intersection.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Polyhedra.convexhull","page":"Utilities","title":"Polyhedra.convexhull","text":"convexhull(P1::VRep, P2::VRep)\n\nTakes the convex hull of P1 and P2  lambda x + (1-lambda) y  x in P_1 y in P_2 . It is very efficient between two V-representations or between two polyhedron for which the V-representation has already been computed. However, if P1 (resp. P2) is a polyhedron for which the V-representation has not been computed yet, it will trigger a representation conversion which is costly.\n\nThe type of the result will be chosen closer to the type of P1. For instance, if P1 is a polyhedron (resp. V-representation) and P2 is a V-representation (resp. polyhedron), convexhull(P1, P2) will be a polyhedron (resp. V-representation). If P1 and P2 are both polyhedra (resp. V-representation), the resulting polyhedron type (resp. V-representation type) will be computed according to the type of P1. The coefficient type however, will be promoted as required taking both the coefficient type of P1 and P2 into account.\n\n\n\n\n\nconvexhull(p1::HRepresentation, p2::HRepresentation)\n\nReturns the Balas [Theorem 3.3, B85] extended H-representation of the convex hull of p1 and p2.\n\n[B85] Balas, E., 1985. Disjunctive programming and a hierarchy of relaxations for discrete optimization problems. SIAM Journal on Algebraic Discrete Methods, 6(3), pp.466-486.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Polyhedra.convexhull!","page":"Utilities","title":"Polyhedra.convexhull!","text":"convexhull!(p1::VRep, p2::VRep)\n\nSame as convexhull except that p1 is modified to be equal to the convex hull.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Polyhedra.translate","page":"Utilities","title":"Polyhedra.translate","text":"translate(p::Polyhedra.Rep, v::AbstractVector)\n\nComputes translation of the polyhedron p with the vector v. That is, computes\n\n x + v mid x in p \n\nBy default, if the H-representation, it simply translates every hyperplanes and halfspace, otherwise, it translates every points of the V-representation. That is, this operation can be achieved both in the H-representation and V-representation hence does not trigger any representation conversion.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Polyhedra.polar","page":"Utilities","title":"Polyhedra.polar","text":"polar(rep::Representation)\n\nReturn the polar of the polyhedron rep assumed to contain the origin. The polar of a convex set S is defined as the set of y such that ⟨x, y⟩ ≤ 1 for all x in S. Note that the polar of a V-representation is a H-representation and vice versa.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Volume","page":"Utilities","title":"Volume","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"volume\nsurface\ncenter_of_mass","category":"page"},{"location":"utilities/#Polyhedra.volume","page":"Utilities","title":"Polyhedra.volume","text":"volume(p::Polyhedron{T}) where {T}\n\nReturns the fulldim(p)-dimensional hyper-volume of the polyhedron p. Returns Inf or -one(T) if it is infinite depending on whether the type T has an infinite value.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Polyhedra.surface","page":"Utilities","title":"Polyhedra.surface","text":"surface(p::Polyhedron{T}) where {T}\n\nReturns the fulldim(p)-1-dimensional hyper-volume of the surface of the polyhedron p. Returns Inf or -one(T) if it is infinite depending on whether the type T has an infinite value.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Polyhedra.center_of_mass","page":"Utilities","title":"Polyhedra.center_of_mass","text":"center_of_mass(p::Polyhedron{T}) where {T}\n\nReturns the center of mass of p, represented as a Vector{T} of length fulldim(p). Throws an error if p is degenerate.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Largest-inscribed-ball-with-center","page":"Utilities","title":"Largest inscribed ball with center","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"maximum_radius_with_center","category":"page"},{"location":"utilities/#Polyhedra.maximum_radius_with_center","page":"Utilities","title":"Polyhedra.maximum_radius_with_center","text":"maximum_radius_with_center(h::HRep, center)\n\nReturn the maximum radius r such that the Euclidean ball of center center and radius r is included in the polyhedron h.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Chebyshev-center","page":"Utilities","title":"Chebyshev center","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"chebyshevcenter\nhchebyshevcenter\nvchebyshevcenter","category":"page"},{"location":"utilities/#Polyhedra.chebyshevcenter","page":"Utilities","title":"Polyhedra.chebyshevcenter","text":"chebyshevcenter(p::Rep[, solver])\n\nIf p is a H-representation or is a polyhedron for which the H-representation has already been computed, calls hchebyshevcenter, otherwise, call vchebyshevcenter.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Polyhedra.hchebyshevcenter","page":"Utilities","title":"Polyhedra.hchebyshevcenter","text":"hchebyshevcenter(p::HRep[, solver]; linearity_detected=false, proper=true)\n\nReturn a tuple with the center and radius of the largest euclidean ball contained in the polyhedron p. Throws an error if the polyhedron is empty or if the radius is infinite. Linearity is detected first except if linearity_detected.\n\nNote that a polytope may have several Chebyshev center. In general, the set of Chebyshev center of a polytope p is a polytope which has a lower dimension than p if p has a positive dimension. For instance, if p is the rectangle [-2, 2] x [-1, 1], the Chebyshev radius of p is 1 and the set of Chebyshev centers is [-1, 1] x {0}. The proper Chebyshev center is (0, 0), the Chebyshev center of [-1, 1] x {0}. If !proper then any Chebyshev center is returned (the one returned depends on the solver). Otherwise the proper Chebyshev center is computed. The proper Chebyshev center is defined by induction on the dimension of p. If p has dimension 0 then it is a singleton and its proper Chebyshev center   is the only element of p. Otherwise, the dimension of the set q of Chebyshev centers of p is smaller than the dimension of p and the proper Chebyshev center of p is the proper Chebyshev center of q.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Polyhedra.vchebyshevcenter","page":"Utilities","title":"Polyhedra.vchebyshevcenter","text":"vchebyshevcenter(p::VRep[, solver])\n\nReturn a tuple with the center and radius of the smallest euclidean ball containing the polyhedron p. Throws an error if the polyhedron is empty or if the radius is infinite (i.e. p is not a polytope, it contains rays).\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Defining-new-representation","page":"Utilities","title":"Defining new representation","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"The following macros make it easy to define new representations:","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"Polyhedra.@subrepelem\nPolyhedra.@norepelem\nPolyhedra.@vecrepelem","category":"page"},{"location":"utilities/#Polyhedra.@subrepelem","page":"Utilities","title":"Polyhedra.@subrepelem","text":"The representation rep contain the elements elem inside a representation in the field field.\n\n\n\n\n\n","category":"macro"},{"location":"utilities/#Polyhedra.@norepelem","page":"Utilities","title":"Polyhedra.@norepelem","text":"The representation rep does not contain any elem.\n\n\n\n\n\n","category":"macro"},{"location":"utilities/#Polyhedra.@vecrepelem","page":"Utilities","title":"Polyhedra.@vecrepelem","text":"The representation rep contain the elements elem inside a vector in the field field.\n\n\n\n\n\n","category":"macro"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"This section shows how to install Julia, Polyhedra and a Polyhedra Manipulation Library of your choice.","category":"page"},{"location":"installation/#Getting-Julia","page":"Installation","title":"Getting Julia","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"The first step is to install Julia. Polyhedra supports Julia v1.0 but the latest version only supports Julia v1.3 or later. Download links and more detailed instructions are available on the Julia website.","category":"page"},{"location":"installation/#Getting-Polyhedra","page":"Installation","title":"Getting Polyhedra","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Open a Julia console (e.g. enter julia at the command line) and write","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"] add Polyhedra","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"To start using Polyhedra, you can now just write","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> using Polyhedra","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Polyhedra includes a default library supporting every operation but external libraries can also be used. See the next section on installing a library.","category":"page"},{"location":"installation/#Getting-Libraries","page":"Installation","title":"Getting Libraries","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Many C libraries are available for manipulating Polyhedra. Some of them work with floating point arithmetic and some of them can do the computation exactly using rational arithmetic and multiple precision libraries such as GMP. Julia also natively supports rational arithmetic using multiple precision libraries and of course floating point arithmetic. That makes the use of both types of arithmetic very easy and transparent. A list of Polyhedra Manipulation Libraries is available in the JuliaPolyhedra website.","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"EditURL = \"https://github.com/JuliaPolyhedra/Polyhedra.jl/blob/master/examples/Minimal Robust Positively Invariant Set.jl\"","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/#Minimal-Robust-Positively-Invariant-Set","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"","category":"section"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/#Introduction","page":"Minimal Robust Positively Invariant Set","title":"Introduction","text":"","category":"section"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"In this example, we implement the method presented in [RKKM05] to compute a robust positively invariant polytope of a linear system under a disturbance bounded by a polytopic set.","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"We consider the example given in equation (15) of [RKKM05]:","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"x^+ =\nbeginbmatrix\n  1  1\n  0  1\nendbmatrixx +\nbeginbmatrix\n  1\n  1\nendbmatrix u\n+ w","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"with the state feedback control u(x) = -beginbmatrix117  103endbmatrix x. The controlled system is therefore","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"x^+ =\nleft(beginbmatrix\n  1  1\n  0  1\nendbmatrix -\nbeginbmatrix\n  1\n  1\nendbmatrix\nbeginbmatrix117  103endbmatrixright)x\n+ w =\nbeginbmatrix\n  -017  -003\n  -117  -003\nendbmatrixx\n+ w","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"[RKKM05] Sasa V. Rakovic, Eric C. Kerrigan, Konstantinos I. Kouramas, David Q. Mayne Invariant approximations of the minimal robust positively Invariant set. IEEE Transactions on Automatic Control 50 (2005): 406-410.","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"A = [1 1; 0 1] - [1; 1] * [1.17 1.03]","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"The set of disturbance is the unit ball of the infinity norm.","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"using Polyhedra\nWv = vrep([[x, y] for x in [-1.0, 1.0] for y in [-1.0, 1.0]])","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"We will use the default library for this example but feel free to pick any other library from this list of available libraries such as CDDLib. The LP solver used to detect redundant points in the V-representation is GLPK. Again, you can replace it with any other solver listed here that supports LP.","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"using GLPK\nusing JuMP\nlib = DefaultLibrary{Float64}(GLPK.Optimizer)\nW = polyhedron(Wv, lib)","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"The F_s function of equation (2) of [RKKM05] can be implemented as follows.","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"function Fs(s::Integer, verbose=1)\n    @assert s ≥ 1\n    F = W\n    A_W = W\n    for i in 1:(s-1)\n        A_W = A * A_W\n        F += A_W\n        if verbose ≥ 1\n            println(\"Number of points after adding A^$i * W: \", npoints(F))\n        end\n        removevredundancy!(F)\n        if verbose ≥ 1\n            println(\"Number of points after removing redundant ones: \", npoints(F))\n        end\n    end\n    return F\nend","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"We can see below that only the V-representation is computed. In fact, no H-representation was ever computed during Fs. Computing AW is done by multiplying all the points by A and doing the Minkowski sum is done by summing each pair of points. The redundancy removal is carried out by CDD's internal LP solver.","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"@time Fs(4)","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"The Figure 1 of [RKKM05] can be reproduced as follows:","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"using Plots\nplot()\nfor i in 10:-1:1\n    plot!(Fs(i, 0))\nend","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"The cell needs to return the plot for it to be displayed but the for loop returns nothing so we add this dummy plot! that returns the plot","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"plot!()","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"Now, suppose we want to compute an invariant set by scaling F_s by the appropriate alpha. In equation (11) of [RKKM05], we want to check whether A^s W subseteq alpha W which is equivalent to W subseteq alpha A^-s W. Note that A^s \\ W triggers the computation of the H-representation of W and A_W is H-represented.","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"function αo(s)\n    A_W = A^s \\ W\n    hashyperplanes(A_W) && error(\"HyperPlanes not supported\")\n    return maximum([Polyhedra.support_function(h.a, W) / h.β for h in halfspaces(A_W)])\nend","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"We obtain alpha approx 19 cdot 10^-5 like in [RKKM05].","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"α = αo(10)","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"The scaled set is is the following:","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"using Plots\nplot((1 - α)^(-1) * Fs(10, 0))","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"","category":"page"},{"location":"generated/Minimal Robust Positively Invariant Set/","page":"Minimal Robust Positively Invariant Set","title":"Minimal Robust Positively Invariant Set","text":"This page was generated using Literate.jl.","category":"page"},{"location":"plot/#Plot","page":"Plot","title":"Plot","text":"","category":"section"},{"location":"plot/","page":"Plot","title":"Plot","text":"Polyhedra contains utilities to visualize either a 2-dimensional or a 3-dimensional polyhedron, see Polyhedron for how to construct a polyhedron, e.g. from its H- or V-representation.","category":"page"},{"location":"plot/#D-plotting-with-Plots","page":"Plot","title":"2D plotting with Plots","text":"","category":"section"},{"location":"plot/","page":"Plot","title":"Plot","text":"A 2-dimensional polyhedron can be visualized either","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"with Plots if it is bounded or\nwith MeshCat or Makie whether it is bounded or not (if it is not bounded, it will be truncated).","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"In this section, we show how to plot 2-dimensional polytopes with Plots. The procedure for plotting 2-dimensional polyhedra with MeshCat or Makie is identical to the plotting of 3-dimensional polyhedra; see the 3D section below.","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"Suppose for instance that we want to visualize the polyhedron having the following H-representation:","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"using Polyhedra\nh = HalfSpace([1, 1], 1) ∩ HalfSpace([-1, 0], 0) ∩ HalfSpace([0, -1], 0)","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"The H-representation cannot be given to Plots directly, it first need to be transformed into a polyhedron:","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"p = polyhedron(h)","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"The polyhedron can be given to Plots as follows. We use ratio=:equal so that the horizontal and vertical axis have the same scale.","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"using Plots\nplot(p, ratio=:equal)","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"See Polyhedral Function and 3D Plotting a projection of the 4D permutahedron for example notebooks.","category":"page"},{"location":"plot/#D-plotting-with-Plots-2","page":"Plot","title":"3D plotting with Plots","text":"","category":"section"},{"location":"plot/","page":"Plot","title":"Plot","text":"A 3-dimensional polyhedron can be visualized with either MeshCat or Makie. Unbounded polyhedron are supported by truncating the polyhedron into a polytope and not triangularizing the faces in the directions of unbounded rays.","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"Suppose for instance that we want to visualize the polyhedron having the following H-representation:","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"julia> using Polyhedra\n\njulia> v = convexhull([0, 0, 0]) + conichull([1, 0, 0], [0, 1, 0], [0, 0, 1])\nV-representation Polyhedra.Hull{Int64, Vector{Int64}, Int64}:\n1-element iterator of Vector{Int64}:\n [0, 0, 0],\n3-element iterator of Ray{Int64, Vector{Int64}}:\n Ray([1, 0, 0])\n Ray([0, 1, 0])\n Ray([0, 0, 1])","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"The V-representation cannot be given to MeshCat or Makie directly, it first need to be transformed into a polyhedron:","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"julia> p = polyhedron(v)\nPolyhedron DefaultPolyhedron{Rational{BigInt}, Polyhedra.Intersection{Rational{BigInt}, Vector{Rational{BigInt}}, Int64}, Polyhedra.Hull{Rational{BigInt}, Vector{Rational{BigInt}}, Int64}}:\n1-element iterator of Vector{Rational{BigInt}}:\n Rational{BigInt}[0//1, 0//1, 0//1],\n3-element iterator of Ray{Rational{BigInt}, Vector{Rational{BigInt}}}:\n Ray(Rational{BigInt}[1//1, 0//1, 0//1])\n Ray(Rational{BigInt}[0//1, 1//1, 0//1])\n Ray(Rational{BigInt}[0//1, 0//1, 1//1])","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"Then, we need to create a mess from the polyhedron:","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"julia> m = Polyhedra.Mesh(p)\nPolyhedra.Mesh{3, Rational{BigInt}, DefaultPolyhedron{Rational{BigInt}, Polyhedra.Intersection{Rational{BigInt}, Vector{Rational{BigInt}}, Int64}, Polyhedra.Hull{Rational{BigInt}, Vector{Rational{BigInt}}, Int64}}}(convexhull([0//1, 0//1, 0//1]) + convexhull(Ray(Rational{BigInt}[1//1, 0//1, 0//1]), Ray(Rational{BigInt}[0//1, 1//1, 0//1]), Ray(Rational{BigInt}[0//1, 0//1, 1//1])), nothing, nothing, nothing)","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"Polyhedra.Mesh","category":"page"},{"location":"plot/#Polyhedra.Mesh","page":"Plot","title":"Polyhedra.Mesh","text":"struct Mesh{N, T, PT <: Polyhedron{T}} <: GeometryBasics.GeometryPrimitive{N, T}\n    polyhedron::PT\n    coordinates::Union{Nothing, Vector{GeometryBasics.Point{3, T}}}\n    faces::Union{Nothing, Vector{GeometryBasics.TriangleFace{Int}}}\n    normals::Union{Nothing, Vector{GeometryBasics.Point{3, T}}}\nend\n\nMesh wrapper type that inherits from GeometryPrimitive to be used for plotting a polyhedron. Note that Mesh(p) is type unstable but one can use Mesh{3}(p) instead if it is known that p is defined in a 3-dimensional space.\n\n\n\n\n\n","category":"type"},{"location":"plot/","page":"Plot","title":"Plot","text":"The polyhedron can be plotted with MeshCat as follows","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"julia> using MeshCat\n\njulia> vis = Visualizer()\n\njulia> setobject!(vis, m)\n\njulia> open(vis)","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"To plot it in a notebook, replace open(vis) with IJuliaCell(vis).","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"To plot it with Makie instead, you can use for instance mesh or wireframe.","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"julia> import Makie\n\njulia> Makie.mesh(m, color=:blue)\n\njulia> Makie.wireframe(m)","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"See 3D Plotting a projection of the 4D permutahedron for an example notebook.","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"DocTestSetup = quote\n    using Polyhedra\nend","category":"page"},{"location":"representation/#Representation","page":"Representation","title":"Representation","text":"","category":"section"},{"location":"representation/","page":"Representation","title":"Representation","text":"Polyhedra can be described in 2 different ways.","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"H-representation: As the intersection of finitely many halfspaces given by its facets.\nV-representation: As the convex hull of its vertices + the conic hull of its rays where '+' is the Minkowski sum.","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"HRepresentation\nVRepresentation\nRepresentation","category":"page"},{"location":"representation/#Polyhedra.HRepresentation","page":"Representation","title":"Polyhedra.HRepresentation","text":"HRepresentation{T<:Real}\n\nSupertype for H-representations with coefficient type T.\n\n\n\n\n\n","category":"type"},{"location":"representation/#Polyhedra.VRepresentation","page":"Representation","title":"Polyhedra.VRepresentation","text":"VRepresentation{T<:Real}\n\nSupertype for V-representations coefficient type T.\n\n\n\n\n\n","category":"type"},{"location":"representation/#Polyhedra.Representation","page":"Representation","title":"Polyhedra.Representation","text":"Representation{T<:Real}\n\nSupertype for H-(or V-)representations with coefficient type T.\n\n\n\n\n\n","category":"type"},{"location":"representation/","page":"Representation","title":"Representation","text":"In Polyhedra.jl, those representations are given the respective abstract types HRepresentation and VRepresentation which are themself subtypes of Representation.","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"These functions can be called on both H-representation and V-representation","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"fulldim\nPolyhedra.FullDim\nPolyhedra.coefficient_type","category":"page"},{"location":"representation/#Polyhedra.fulldim","page":"Representation","title":"Polyhedra.fulldim","text":"fulldim(rep::Rep)::Int\n\nReturns the dimension of the space in which polyhedron, representation, element or vector is defined. That is, a straight line in a 3D space has fulldim 3 even if its dimension is 1.\n\n\n\n\n\n","category":"function"},{"location":"representation/#Polyhedra.FullDim","page":"Representation","title":"Polyhedra.FullDim","text":"FullDim(p)::FullDim\n\nSimilar to fulldim but used for type stability with the vector type. If the vector type is StaticArrays.SVector then it returns a StaticArrays.Size.\n\n\n\n\n\n","category":"type"},{"location":"representation/#Polyhedra.coefficient_type","page":"Representation","title":"Polyhedra.coefficient_type","text":"coefficient_type(rep::Rep)\n\nReturns the type of the coefficients used in the representation of rep.\n\n\n\n\n\n","category":"function"},{"location":"representation/#H-representation","page":"Representation","title":"H-representation","text":"","category":"section"},{"location":"representation/","page":"Representation","title":"Representation","text":"The fundamental element of an H-representation is the halfspace","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"HalfSpace","category":"page"},{"location":"representation/#Polyhedra.HalfSpace","page":"Representation","title":"Polyhedra.HalfSpace","text":"struct HalfSpace{T, AT} <: HRepElement{T, AT}\n    a::AT\n    β::T\nend\n\nAn halfspace defined by the set of points x such that langle a x rangle le beta.\n\n\n\n\n\n","category":"type"},{"location":"representation/","page":"Representation","title":"Representation","text":"An H-representation can be created as the intersection of several halfspaces. For instance, the polytope","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"beginaligned\n  x_1 + x_2 leq 1 \n  x_1 - x_2 leq 0 \n  x_1  geq 0\nendaligned","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"can be created as follows:","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"HalfSpace([1, 1], 1) ∩ HalfSpace([1, -1], 0) ∩ HalfSpace([-1, 0], 0)","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"Even if HalfSpaces are enough to describe any polyhedron, it is sometimes important to represent the fact that the polyhedron is contained in an affine subspace. For instance, the simplex","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"beginaligned\n  x_1 + x_2 = 1 \n  x_1 geq 0 \n  x_2 geq 0\nendaligned","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"is 1-dimensional even if it is defined in a 2-dimensional space.","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"The fundamental element of an affine subspace is the hyperplane","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"HyperPlane","category":"page"},{"location":"representation/#Polyhedra.HyperPlane","page":"Representation","title":"Polyhedra.HyperPlane","text":"struct HyperPlane{T, AT} <: HRepElement{T, AT}\n    a::AT\n    β::T\nend\n\nAn hyperplane defined by the set of points x such that langle a x rangle = beta.\n\n\n\n\n\n","category":"type"},{"location":"representation/","page":"Representation","title":"Representation","text":"An affine subspace can be created as the intersection of several hyperplanes. For instance","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"HyperPlane([1, 1], 1) ∩ HyperPlane([1, 0], 0)","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"represents the 0-dimensional affine subspace only containing the point (0 1).","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"To represent a polyhedron that is not full-dimensional, hyperplanes and halfspaces can be mixed in any order. For instance, the simplex defined above can be obtained as follows:","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"HalfSpace([-1, 0], 0) ∩ HyperPlane([1, 1], 1) ∩ HalfSpace([0, -1], 0)","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"In addition to being created incrementally with intersections, an H-representation can also be created using the hrep function. The hrep function is also used to query the H-representation of a given polyhedron.","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"hrep","category":"page"},{"location":"representation/#Polyhedra.hrep","page":"Representation","title":"Polyhedra.hrep","text":"hrep(p::Polyhedron)\n\nReturns an H-representation for the polyhedron p.\n\n\n\n\n\nhrep(hyperplanes::HyperPlaneIt; d::FullDim)\n\nCreates an affine space of full dimension d from the list of hyperplanes hyperplanes.\n\nExamples\n\nhrep([HyperPlane([0, 1, 0], 1), HyperPlane([0, 0, 1], 0)])\n\ncreates the 1-dimensional affine subspace containing all the points (x_1 0 0), i.e. the x_1-axis.\n\nhrep([HyperPlane([1, 1], 1), HyperPlane([1, 0], 0)])\n\ncreates the 0-dimensional affine subspace only containing the point (0 1).\n\n\n\n\n\nhrep(hyperplanes::HyperPlaneIt, halfspaces::HalfSpaceIt; d::FullDim)\n\nCreates an H-representation for the polyhedron of full dimension d equal to the intersection of the hyperplanes hyperplanes and halfspaces halfspaces.\n\nExamples\n\nFor instance, the simplex\n\nbeginaligned\n  x_1 + x_2 = 1 \n  x_1 geq 0 \n  x_2 geq 0\nendaligned\n\ncan be created as follows:\n\njulia> hrep([HyperPlane([1, 1], 1)], [HalfSpace([0, -1], 0), HalfSpace([-1, 0], 0)])\nH-representation Polyhedra.Intersection{Int64, Vector{Int64}, Int64}:\n1-element iterator of HyperPlane{Int64, Vector{Int64}}:\n HyperPlane([1, 1], 1),\n2-element iterator of HalfSpace{Int64, Vector{Int64}}:\n HalfSpace([0, -1], 0)\n HalfSpace([-1, 0], 0)\n\n\n\n\n\nhrep(halfspaces::HalfSpaceIt; d::FullDim)\n\nCreates an H-representation for the polyhedron of full dimension d equal to the intersection of the halfspaces halfspaces.\n\nExamples\n\nFor instance, the polytope\n\nbeginaligned\n  x_1 + x_2 leq 1 \n  x_1 - x_2 leq 0 \n  x_1  geq 0\nendaligned\n\ncan be created as follows:\n\nhrep([HalfSpace([1, 1], 1), HalfSpace([1, -1], 0), HalfSpace([-1, 0], 0)])\n\n\n\n\n\nhrep(model::JuMP.Model)\n\nBuilds an H-representation from the feasibility set of the JuMP model model. Note that if non-linear constraint are present in the model, they are ignored.\n\n\n\n\n\nhrep(A::AbstractMatrix, b::AbstractVector, linset::BitSet=BitSet())\n\nCreates an H-representation for the polyhedron defined by the inequalities langle A_i x rangle = b_i if i in linset and langle A_i x rangle le b_i otherwise where A_i is the ith row of A, i.e. A[i,:] and b_i is b[i].\n\n\n\n\n\n","category":"function"},{"location":"representation/","page":"Representation","title":"Representation","text":"The H-representation of a given polyhedron can be altered with the Polyhedra.resethrep! and Polyhedra.sethrep!. Use Polyhedra.sethrep! with caution as it does not invalidate the V-representation! Use Polyhedra.resethrep! in case you are unsure on which one to use.","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"Polyhedra.resethrep!\nPolyhedra.sethrep!","category":"page"},{"location":"representation/#Polyhedra.resethrep!","page":"Representation","title":"Polyhedra.resethrep!","text":"Polyhedra.resethrep!(p::Polyhedron, h::HRepresentation, redundancy::Redundancy = UNKNOWN_REDUNDANCY)\n\nReset the H-representation of p to h. The redundancy of p is assumed to be redundancy; see Polyhedra.Redundancy.\n\ninfo: Info\nThe representation is not assumed to be a valid representation for p so it invalidates the V-representation of p. Use Polyhedra.sethrep! if h is known to be a valid representation for p.\n\n\n\n\n\n","category":"function"},{"location":"representation/#Polyhedra.sethrep!","page":"Representation","title":"Polyhedra.sethrep!","text":"Polyhedra.sethrep!(p::Polyhedron, h::HRepresentation, redundancy::Redundancy = UNKNOWN_REDUNDANCY)\n\nReset the H-representation of p to h. The redundancy of p is assumed to be redundancy; see Polyhedra.Redundancy.\n\nwarning: Warning\nThe representation is assumed to be a valid representation for p so it does not invalidate the V-representation of p if it was already computed previously. Use Polyhedra.resethrep! if h is not known to be a valid representation for p.\n\n\n\n\n\n","category":"function"},{"location":"representation/#Interface","page":"Representation","title":"Interface","text":"","category":"section"},{"location":"representation/","page":"Representation","title":"Representation","text":"An H-representation is represented as an intersection halfspaces and hyperplanes. The halfspaces can be obtained with halfspaces and the hyperplanes with hyperplanes. As an hyperplane langle a x rangle = beta is the intersection of the two halfspaces langle a x rangle le beta and langle a x rangle ge beta, even if the H-representation contains hyperplanes, a list of halfspaces whose intersection is the polyhedron can be obtained with allhalfspaces, which has nhalfspaces(p) + 2nhyperplanes(p) elements for an H-representation p since each hyperplane is split in two halfspaces.","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"halfspaces\nnhalfspaces\nhashalfspaces\nhyperplanes\nnhyperplanes\nhashyperplanes\nallhalfspaces\nnallhalfspaces\nhasallhalfspaces","category":"page"},{"location":"representation/#Polyhedra.halfspaces","page":"Representation","title":"Polyhedra.halfspaces","text":"halfspaces(hrep::HRep)\n\nReturns an iterator over the halfspaces of the H-representation hrep.\n\n\n\n\n\n","category":"function"},{"location":"representation/#Polyhedra.nhalfspaces","page":"Representation","title":"Polyhedra.nhalfspaces","text":"nhalfspaces(hrep::HRep)\n\nReturns the number of halfspaces of the H-representation hrep.\n\n\n\n\n\n","category":"function"},{"location":"representation/#Polyhedra.hashalfspaces","page":"Representation","title":"Polyhedra.hashalfspaces","text":"hashalfspaces(hrep::HRep)\n\nReturns whether the H-representation hrep has any halfspace.\n\n\n\n\n\n","category":"function"},{"location":"representation/#Polyhedra.hyperplanes","page":"Representation","title":"Polyhedra.hyperplanes","text":"hyperplanes(hrep::HRep)\n\nReturns an iterator over the hyperplanes of the H-representation hrep.\n\n\n\n\n\n","category":"function"},{"location":"representation/#Polyhedra.nhyperplanes","page":"Representation","title":"Polyhedra.nhyperplanes","text":"nhyperplanes(hrep::HRep)\n\nReturns the number of hyperplanes of the H-representation hrep.\n\n\n\n\n\n","category":"function"},{"location":"representation/#Polyhedra.hashyperplanes","page":"Representation","title":"Polyhedra.hashyperplanes","text":"hashyperplanes(hrep::HRep)\n\nReturns whether the H-representation hrep has any hyperplane.\n\n\n\n\n\n","category":"function"},{"location":"representation/#Polyhedra.allhalfspaces","page":"Representation","title":"Polyhedra.allhalfspaces","text":"allhalfspaces(hrep::HRep)\n\nReturns an iterator over the halfspaces and hyperplanes in the H-representation hrep splitting hyperplanes in two halfspaces.\n\nExamples\n\nhrep = HyperPlane([1, 0], 1) ∩ HalfSpace([0, 1], 1)\ncollect(allhalfspaces(hrep)) # Returns [HalfSpace([1, 0]), HalfSpace([-1, 0]), HalfSpace([0, 1])]\n\n\n\n\n\n","category":"function"},{"location":"representation/#Polyhedra.nallhalfspaces","page":"Representation","title":"Polyhedra.nallhalfspaces","text":"nallhalfspaces(hrep::HRep)\n\nReturns the number of halfspaces plus twice the number of hyperplanes in the H-representation hrep, i.e. length(allhalfspaces(hrep))\n\n\n\n\n\n","category":"function"},{"location":"representation/#Polyhedra.hasallhalfspaces","page":"Representation","title":"Polyhedra.hasallhalfspaces","text":"hasallhalfspaces(hrep::HRep)\n\nReturns whether the H-representation hrep contains any halfspace or hyperplane.\n\n\n\n\n\n","category":"function"},{"location":"representation/#V-representation","page":"Representation","title":"V-representation","text":"","category":"section"},{"location":"representation/","page":"Representation","title":"Representation","text":"The fundamental elements of an V-representation are the points (represented by AbstractVectors and and rays","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"Ray","category":"page"},{"location":"representation/#Polyhedra.Ray","page":"Representation","title":"Polyhedra.Ray","text":"struct Ray{T, AT <: AbstractVector{T}}\n    a::AT\nend\n\nThe conic hull of a, i.e. the set of points λa where λ is any nonnegative real number.\n\n\n\n\n\n","category":"type"},{"location":"representation/","page":"Representation","title":"Representation","text":"A V-representation can be created as the minkowski sum between a convex hull of points and a conic hull of rays. For instance, the positive orthant without the simplex defined in the H-representation section can be created as follows:","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"convexhull([1, 0], [0, 1]) + conichull([1, 0], [0, 1])","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"The V-representation represents the polyhedron as a minkowski sum of a polytope and a polyhedral cone. The polytope is represented using a P-representation : a convex hull of points. The polyhedral cone is represented using an R-representation : a conic hull of rays.","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"Even if rays are enough to describe any polyhedral cone, it is sometimes important to represent the fact that the polyhedron contains an affine subspace. For instance, the polyhedron created with","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"convexhull([1, 0], [0, 1]) + conichull([1, 1], [-1, -1])","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"contains the line [1, 1].","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"The fundamental element of an affine subspace is the line","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"Line","category":"page"},{"location":"representation/#Polyhedra.Line","page":"Representation","title":"Polyhedra.Line","text":"struct Line{T, AT <: AbstractVector{T}}\n    a::AT\nend\n\nThe conic hull of a and -a, i.e. the set of points λa where λ is any real number.\n\n\n\n\n\n","category":"type"},{"location":"representation/","page":"Representation","title":"Representation","text":"An affine subspace can be created as the conic hull/minkownski sum of several lines. For instance","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"conichull(Line([1, 0]), Line([0, 1]))","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"represents the full space.","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"In addition to being created incrementally with convex hull and minkowsky addition, a V-representation can also be created using the vrep function. The vrep function is also used to query the V-representation of a given polyhedron.","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"vrep","category":"page"},{"location":"representation/#Polyhedra.vrep","page":"Representation","title":"Polyhedra.vrep","text":"vrep(p::Polyhedron)\n\nReturns a V-representation for the polyhedron p.\n\n\n\n\n\nvrep(lines::LineIt; d::FullDim)\n\nCreates an affine space of full dimension d from the list of lines lines.\n\nExamples\n\nvrep([Line([1, 0, 0]), Line([0, 1, 0])])\n\ncreates the 2-dimensional affine subspace containing all the points (x_1 x_2 0), i.e. the x_1x_2-plane.\n\n\n\n\n\nvrep(points::PointIt; d::FullDim)\n\nCreates a V-representation for the polytope of full dimension d equal to the convex hull of the points points.\n\nExamples\n\nThe convex hull of (0 0), (0 1) and (12 12) can be created as follows using exact arithmetic\n\nvrep([[0, 0], [0, 1], [1//2, 1//2]])\n\nor as follows using floating point arithmetic\n\nvrep([[0, 0], [0, 1], [1/2, 1/2]])\n\n\n\n\n\nvrep(lines::LineIt, rays::RayIt; d::FullDim)\n\nCreates a V-representation for the polyhedral cone of full dimension d equal to the conic hull of the lines lines and rays rays.\n\nExamples\n\nvrep([Line([0, 1])], [Ray([1, 0])])\n\ncreates a V-representation for the halfspace x_1 ge 0.\n\n\n\n\n\nvrep(rays::RayIt)\n\nCreates a V-representation for the polyhedral cone of full dimension d equal to the conic hull of the rays rays.\n\nExamples\n\nvrep([Ray([1, 0]), Ray([0, 1])])\n\ncreates a V-representation for positive orthant.\n\n\n\n\n\nvrep(points::PointIt, lines::LineIt, rays::RayIt;\n     d = Polyhedra.FullDim_rec(points, lines, rays))\n\nCreates a V-representation for the polyhedron of full dimension d equal to the minkowski sum of the convex hull of points with the conic hull of lines and rays.\n\n\n\n\n\nvrep(V::AbstractMatrix, R::AbstractMatrix, Rlinset::BitSet=BitSet())\n\nCreates a V-representation for the polyhedron defined by the points V_i, lines R_i if i in Rlinset and rays R_i otherwise where V_i (resp. R_i) is the ith row of V (resp. R), i.e. V[i,:] (resp. R[i,:]).\n\n\n\n\n\n","category":"function"},{"location":"representation/","page":"Representation","title":"Representation","text":"The H-representation of a given polyhedron can be altered with the Polyhedra.resetvrep! and Polyhedra.setvrep!. Use Polyhedra.setvrep! with caution as it does not invalidate the V-representation! Use Polyhedra.resetvrep! in case you are unsure on which one to use.","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"Polyhedra.resetvrep!\nPolyhedra.setvrep!","category":"page"},{"location":"representation/#Polyhedra.resetvrep!","page":"Representation","title":"Polyhedra.resetvrep!","text":"Polyhedra.resetvrep!(p::Polyhedron, v::VRepresentation, redundancy::Redundancy = UNKNOWN_REDUNDANCY)\n\nReset the V-representation of p to v. The redundancy of p is assumed to be redundancy; see Polyhedra.Redundancy.\n\ninfo: Info\nThe representation is not assumed to be a valid representation for p so it invalidates the H-representation of p. Use Polyhedra.setvrep! if v is known to be a valid representation for p.\n\n\n\n\n\n","category":"function"},{"location":"representation/#Polyhedra.setvrep!","page":"Representation","title":"Polyhedra.setvrep!","text":"Polyhedra.setvrep!(p::Polyhedron, v::HRepresentation, redundancy::Redundancy = UNKNOWN_REDUNDANCY)\n\nReset the H-representation of p to v. The redundancy of p is assumed to be redundancy; see Polyhedra.Redundancy.\n\nwarning: Warning\nThe representation is assumed to be a valid representation for p so it does not invalidate the H-representation of p if it was already computed previously. Use Polyhedra.resetvrep! if v is not known to be a valid representation for p.\n\n\n\n\n\n","category":"function"},{"location":"representation/#Interface-2","page":"Representation","title":"Interface","text":"","category":"section"},{"location":"representation/","page":"Representation","title":"Representation","text":"A P-representation is represented as a convex hull points. The points can be obtained with points.","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"points\nnpoints\nhaspoints","category":"page"},{"location":"representation/#Polyhedra.points","page":"Representation","title":"Polyhedra.points","text":"points(vrep::VRep)\n\nReturns an iterator over the points of the V-representation vrep.\n\n\n\n\n\n","category":"function"},{"location":"representation/#Polyhedra.npoints","page":"Representation","title":"Polyhedra.npoints","text":"npoints(vrep::VRep)\n\nReturns the number of points of the V-representation vrep.\n\n\n\n\n\n","category":"function"},{"location":"representation/#Polyhedra.haspoints","page":"Representation","title":"Polyhedra.haspoints","text":"haspoints(vrep::VRep)\n\nReturns whether the V-representation vrep has any point.\n\n\n\n\n\n","category":"function"},{"location":"representation/","page":"Representation","title":"Representation","text":"An R-representation is represented as a conic hull of lines and rays. The rays can be obtained with rays and the lines with lines. As a line r is the conic hull of of the two rays r and -r, even if the R-representation contains lines, a list of rays whose conic hull is the polyhedral cone can be obtained with allrays, which has nrays(R) + 2nlines(R) elements for an R-representation R since each line is split in two rays.","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"rays\nnrays\nhasrays\nlines\nnlines\nhaslines\nallrays\nnallrays\nhasallrays","category":"page"},{"location":"representation/#Polyhedra.rays","page":"Representation","title":"Polyhedra.rays","text":"rays(vrep::VRep)\n\nReturns an iterator over the rays of the V-representation vrep.\n\n\n\n\n\n","category":"function"},{"location":"representation/#Polyhedra.nrays","page":"Representation","title":"Polyhedra.nrays","text":"nrays(vrep::VRep)\n\nReturns the number of rays of the V-representation vrep.\n\n\n\n\n\n","category":"function"},{"location":"representation/#Polyhedra.hasrays","page":"Representation","title":"Polyhedra.hasrays","text":"hasrays(vrep::VRep)\n\nReturns whether the V-representation vrep has any ray.\n\n\n\n\n\n","category":"function"},{"location":"representation/#Polyhedra.lines","page":"Representation","title":"Polyhedra.lines","text":"lines(vrep::VRep)\n\nReturns an iterator over the lines of the V-representation vrep.\n\n\n\n\n\n","category":"function"},{"location":"representation/#Polyhedra.nlines","page":"Representation","title":"Polyhedra.nlines","text":"nlines(vrep::VRep)\n\nReturns the number of lines of the V-representation vrep.\n\n\n\n\n\n","category":"function"},{"location":"representation/#Polyhedra.haslines","page":"Representation","title":"Polyhedra.haslines","text":"haslines(vrep::VRep)\n\nReturns whether the V-representation vrep has any line.\n\n\n\n\n\n","category":"function"},{"location":"representation/#Polyhedra.allrays","page":"Representation","title":"Polyhedra.allrays","text":"allrays(vrep::VRep)\n\nReturns an iterator over the rays and lines in the V-representation vrep splitting lines in two rays.\n\nExamples\n\nvrep = Line([1, 0]) + Ray([0, 1])\ncollect(allrays(vrep)) # Returns [Ray([1, 0]), Ray([-1, 0]), Ray([0, 1])]\n\n\n\n\n\n","category":"function"},{"location":"representation/#Polyhedra.nallrays","page":"Representation","title":"Polyhedra.nallrays","text":"nallrays(vrep::VRep)\n\nReturns the number of rays plus twice the number of lines in the V-representation vrep, i.e. length(allrays(vrep))\n\n\n\n\n\n","category":"function"},{"location":"representation/#Polyhedra.hasallrays","page":"Representation","title":"Polyhedra.hasallrays","text":"hasallrays(vrep::VRep)\n\nReturns whether the V-representation vrep contains any ray or line.\n\n\n\n\n\n","category":"function"},{"location":"projection/#Projection/Elimination","page":"Projection/Elimination","title":"Projection/Elimination","text":"","category":"section"},{"location":"projection/","page":"Projection/Elimination","title":"Projection/Elimination","text":"Consider the polyhedron created in the beginning of this section. As a reminder, it represents the following H-representation:","category":"page"},{"location":"projection/","page":"Projection/Elimination","title":"Projection/Elimination","text":"beginalign*\n  x_1 + x_2 leq 1 \n  x_1 - x_2 leq 0 \n  x_1  geq 0\nendalign*","category":"page"},{"location":"projection/","page":"Projection/Elimination","title":"Projection/Elimination","text":"One can verify that for any 0 leq x_2 leq 1, there exists a value x_1 such that (x_1 x_2) is in this polyhedron. This means that the H-representation obtained by eliminating x_1 is:","category":"page"},{"location":"projection/","page":"Projection/Elimination","title":"Projection/Elimination","text":"beginalign*\n  x_1  leq 1 \n  x_1  geq 0\nendalign*","category":"page"},{"location":"projection/","page":"Projection/Elimination","title":"Projection/Elimination","text":"where x_1 in the H-representation above represents x_2 in the previous one. This can be obtained as follows","category":"page"},{"location":"projection/","page":"Projection/Elimination","title":"Projection/Elimination","text":"julia> poly_x2 = eliminate(poly, [1])\njulia> hrep(poly_x2)\nH-representation\nbegin\n 2 2 rational\n 1//1 -1//1\n 0//1 1//1\nend","category":"page"},{"location":"projection/","page":"Projection/Elimination","title":"Projection/Elimination","text":"There is two methods of computing the elimination implemented in CDDLib: Fourier-Motzkin elimination and block elimination. As written by K. Fukuda in CDD's documentation, \"[Block elimination] might be a faster way to eliminate variables than the repeated [Fourier-Motzkin elimination] when the number of variables to eliminate is large\". You can specify the method to use as a third argument, e.g. eliminate(poly, [1], FourierMotzkin()), eliminate(poly, [1], BlockElimination()). A third method can be chosen: ProjectGenerators. It computes the V-representation and then project each of its elements. This is the method of choice when the V-representation is already computed.","category":"page"},{"location":"projection/","page":"Projection/Elimination","title":"Projection/Elimination","text":"FourierMotzkin\nBlockElimination\nProjectGenerators","category":"page"},{"location":"projection/#Polyhedra.FourierMotzkin","page":"Projection/Elimination","title":"Polyhedra.FourierMotzkin","text":"FourierMotzkin\n\nComputation of the projection by computing the H-representation and applying the Fourier-Motzkin elimination algorithm to it.\n\nThe resulting polyhedron may contain duplicates and/or redundancy. These can be removed with removehredundancy!.\n\n\n\n\n\n","category":"type"},{"location":"projection/#Polyhedra.BlockElimination","page":"Projection/Elimination","title":"Polyhedra.BlockElimination","text":"BlockElimination\n\nComputation of the projection by computing the H-representation and applying the block elimination algorithm to it.\n\n\n\n\n\n","category":"type"},{"location":"projection/#Polyhedra.ProjectGenerators","page":"Projection/Elimination","title":"Polyhedra.ProjectGenerators","text":"ProjectGenerators\n\nComputation of the projection by computing the V-representation and projecting them.\n\n\n\n\n\n","category":"type"},{"location":"projection/","page":"Projection/Elimination","title":"Projection/Elimination","text":"If nothing is specified as in the block of code above, the behavior depends on the polyhedral library. If neither Fourier-Motzkin nor block elimination is implemented or if the V-representation is already computed then :ProjectGenerators is chosen. Otherwise, Polyhedra lets the library decide. In CDDLib, :FourierMotzkin is chosen when only the last dimension needs to be eliminated and :BlockElimination is chosen otherwise. Note that CDDLib only supports projecting the last trailing dimensions.","category":"page"},{"location":"projection/","page":"Projection/Elimination","title":"Projection/Elimination","text":"eliminate\nproject\nfixandeliminate","category":"page"},{"location":"projection/#Polyhedra.eliminate","page":"Projection/Elimination","title":"Polyhedra.eliminate","text":"eliminate(p::Polyhedron, delset, algo::EliminationAlgorithm)\n\nEliminate the dimensions in delset by projecting the polyhedron onto the remaining dimension.\n\n\n\n\n\n","category":"function"},{"location":"projection/#Polyhedra.project","page":"Projection/Elimination","title":"Polyhedra.project","text":"project(p::Polyhedron, pset, algo)\n\nEquivalent to eliminate(p, setdiff(1:fulldim(p), pset), algo).\n\n\n\n\n\n","category":"function"},{"location":"projection/#Polyhedra.fixandeliminate","page":"Projection/Elimination","title":"Polyhedra.fixandeliminate","text":"fixandeliminate(p::HRep{T}, I, v)\n\nFix the variables with indices in I to the corresponding value in v. This is equivalent to doing the following:\n\nfunction ei(i)\n    a = zeros(T, fulldim(p))\n    a[i] = one(T)\n    a\nend\neliminate(p ∩ HyperPlane(ei(I[1]), v[1]) ∩ ... ∩ HyperPlane(ei(I[n]), v[n]))\n\nwhere n is the length of I (and v), but it is much more efficient. The code above does a polyhedral projection while this function simply replaces each halfspace ⟨a, x⟩ ≤ β (resp. each hyperplane ⟨a, x⟩ = β) by the halfspace ⟨a_J, x⟩ ≤ β - ⟨a_I, v⟩ (resp. the hyperplane ⟨a_J, x⟩ = β - ⟨a_I, v⟩) where J = setdiff(1:fulldim(p), I).\n\n\n\n\n\n","category":"function"},{"location":"generated/Convex hull of a set of points/","page":"Convex hull of a set of points","title":"Convex hull of a set of points","text":"EditURL = \"https://github.com/JuliaPolyhedra/Polyhedra.jl/blob/master/examples/Convex hull of a set of points.jl\"","category":"page"},{"location":"generated/Convex hull of a set of points/#Convex-hull-of-a-set-of-points","page":"Convex hull of a set of points","title":"Convex hull of a set of points","text":"","category":"section"},{"location":"generated/Convex hull of a set of points/#Convex-hull-in-a-plane","page":"Convex hull of a set of points","title":"Convex hull in a plane","text":"","category":"section"},{"location":"generated/Convex hull of a set of points/","page":"Convex hull of a set of points","title":"Convex hull of a set of points","text":"This examples shows how to find the convex hull in the context of a plane. First we have to create an object representing the vertices. We have multiple ways of doing this","category":"page"},{"location":"generated/Convex hull of a set of points/","page":"Convex hull of a set of points","title":"Convex hull of a set of points","text":"using Polyhedra\n\nv = convexhull([0, 0], [0, 1], [1, 0], [0.1, 0.1]) # list of points\nv = vrep([[0, 0], [0, 1], [1, 0], [0.1, 0.1]]) # vector of points","category":"page"},{"location":"generated/Convex hull of a set of points/","page":"Convex hull of a set of points","title":"Convex hull of a set of points","text":"number of points × dimension matrix","category":"page"},{"location":"generated/Convex hull of a set of points/","page":"Convex hull of a set of points","title":"Convex hull of a set of points","text":"x = [0,0,1,0.1]\ny = [0,1,0,0.1]\nv = vrep([x y])","category":"page"},{"location":"generated/Convex hull of a set of points/","page":"Convex hull of a set of points","title":"Convex hull of a set of points","text":"Then we can compute the hull of these points using the planar_hull function","category":"page"},{"location":"generated/Convex hull of a set of points/","page":"Convex hull of a set of points","title":"Convex hull of a set of points","text":"Polyhedra.planar_hull(v)","category":"page"},{"location":"generated/Convex hull of a set of points/#Convex-hull-in-higher-dimension","page":"Convex hull of a set of points","title":"Convex hull in higher dimension","text":"","category":"section"},{"location":"generated/Convex hull of a set of points/","page":"Convex hull of a set of points","title":"Convex hull of a set of points","text":"In higher dimension, we can do it with a linear programming solver implementing the MathOptInterface, e.g.,","category":"page"},{"location":"generated/Convex hull of a set of points/","page":"Convex hull of a set of points","title":"Convex hull of a set of points","text":"import GLPK\n\nremovevredundancy(v, GLPK.Optimizer)","category":"page"},{"location":"generated/Convex hull of a set of points/","page":"Convex hull of a set of points","title":"Convex hull of a set of points","text":"We can also use any Polyhedral library implementing the interface of this package. If we don't specify any library, it falls back to a default one implementing on this package which will use the planar_hull if the dimension is 2 (so it's equivalent to the first approach shown above):","category":"page"},{"location":"generated/Convex hull of a set of points/","page":"Convex hull of a set of points","title":"Convex hull of a set of points","text":"p = polyhedron(v)\nremovevredundancy!(p)\np","category":"page"},{"location":"generated/Convex hull of a set of points/","page":"Convex hull of a set of points","title":"Convex hull of a set of points","text":"We can also specify a library. For instance, to use CDDLib, write using CDDLib and then p = polyhedron(v, CDDLib.Library()).","category":"page"},{"location":"generated/Convex hull of a set of points/","page":"Convex hull of a set of points","title":"Convex hull of a set of points","text":"","category":"page"},{"location":"generated/Convex hull of a set of points/","page":"Convex hull of a set of points","title":"Convex hull of a set of points","text":"This page was generated using Literate.jl.","category":"page"},{"location":"internal/#Internal-functions","page":"Internal","title":"Internal functions","text":"","category":"section"},{"location":"internal/","page":"Internal","title":"Internal","text":"Internal functions.","category":"page"},{"location":"internal/","page":"Internal","title":"Internal","text":"Polyhedra.add_intersection!\nPolyhedra.combine","category":"page"},{"location":"internal/#Polyhedra.add_intersection!","page":"Internal","title":"Polyhedra.add_intersection!","text":"add_intersection!(data, idx1, idx2, hp_idx, hs_idx = hp_idx - 1)\n\nAdd the intersection of the elements of indices idx1 and idx2 that belong to the hyperplane corresponding the halfspace of index hp_idx (see 3.2 (ii) of [FP96]) or have inherited adjacency if hp_idx === nothing (see 3.2 (i) of [FP96]). In case of inherited adjacency, hs_idx is the halfspace where idx1 was created. If idx1 and idx2 are not adjacent or if they are in the hyperplane corresponding to a halfspace of lower index then the intersection is not added to avoid adding redundant elements.\n\n[FP96] Fukuda, K. and Prodon, A. Double description method revisited Combinatorics and computer science, Springer, 1996, 91-111\n\n\n\n\n\n","category":"function"},{"location":"internal/#Polyhedra.combine","page":"Internal","title":"Polyhedra.combine","text":"combine(h::HalfSpace, el1::VRepElement, el2::VRepElement)\n\nCombine el1 and el2 which are on two different sides of the halfspace h so that the combination is in the corresponding hyperplane.\n\n\n\n\n\n","category":"function"},{"location":"generated/Extended Formulation/","page":"Extended Formulation","title":"Extended Formulation","text":"EditURL = \"https://github.com/JuliaPolyhedra/Polyhedra.jl/blob/master/examples/Extended Formulation.jl\"","category":"page"},{"location":"generated/Extended Formulation/#Extended-formulation","page":"Extended Formulation","title":"Extended formulation","text":"","category":"section"},{"location":"generated/Extended Formulation/","page":"Extended Formulation","title":"Extended Formulation","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/Extended Formulation/","page":"Extended Formulation","title":"Extended Formulation","text":"In this notebook, we show how to work with the extended formulation of a polyhedron. The convex hull of the union of polyhedra that are H-represented can be obtained as the projection of a H-representation [Theorem 3.3, B85]. In order to use the resulting polyhedron as a constraint set in an optimization problem, there is no need to compute the resulting H-representation of this projection. Moreover, other operations such as intersection are also implemented between extended H-representations. We illustrate this with a simple example. We start by defining the H-representation of a square with JuMP.","category":"page"},{"location":"generated/Extended Formulation/","page":"Extended Formulation","title":"Extended Formulation","text":"[B85] Balas, E., 1985. Disjunctive programming and a hierarchy of relaxations for discrete optimization problems. SIAM Journal on Algebraic Discrete Methods, 6(3), pp.466-486.","category":"page"},{"location":"generated/Extended Formulation/","page":"Extended Formulation","title":"Extended Formulation","text":"using JuMP\nmodel = Model()\n@variable(model, -1 <= x <= 1)\n@variable(model, -1 <= y <= 1)\nusing Polyhedra\nsquare = hrep(model)","category":"page"},{"location":"generated/Extended Formulation/","page":"Extended Formulation","title":"Extended Formulation","text":"Note that the names of the JuMP variables are used as the names of the corresponding dimensions for the polyhedron square.","category":"page"},{"location":"generated/Extended Formulation/","page":"Extended Formulation","title":"Extended Formulation","text":"dimension_names(square)","category":"page"},{"location":"generated/Extended Formulation/","page":"Extended Formulation","title":"Extended Formulation","text":"In the following, diagonal and antidiag are projections of extended H-representations of dimension 7 hence diamond is a projection of an extended H-representation of dimensions 12.","category":"page"},{"location":"generated/Extended Formulation/","page":"Extended Formulation","title":"Extended Formulation","text":"diagonal = convexhull(translate(square, [-2, -2]), translate(square, [2, 2]))\nantidiag = convexhull(translate(square, [-2,  2]), translate(square, [2, -2]))\ndiamond = diagonal ∩ antidiag","category":"page"},{"location":"generated/Extended Formulation/","page":"Extended Formulation","title":"Extended Formulation","text":"Note that the names the first two dimensions are still identical to the names of the JuMP variables and the auxiliary variables have no name.","category":"page"},{"location":"generated/Extended Formulation/","page":"Extended Formulation","title":"Extended Formulation","text":"dimension_names(diamond.set)","category":"page"},{"location":"generated/Extended Formulation/","page":"Extended Formulation","title":"Extended Formulation","text":"We don't need to compute the result of the projection to solve an optimization problem over diamond. For instance, to compute the maximal value that y can take over this polytope with the GLPK solver, we can do as follows. Note that if we use anonymous JuMP variables, the name of the JuMP variables will be the names of the corresponding dimensions of the polyhedron. Therefore, we can retrieve the JuMP variable according to the corresponding dimension name with variable_by_name.","category":"page"},{"location":"generated/Extended Formulation/","page":"Extended Formulation","title":"Extended Formulation","text":"import GLPK\nmodel = Model(GLPK.Optimizer)\n@variable(model, [1:2] in diamond)\nx = variable_by_name(model, \"x\")\ny = variable_by_name(model, \"y\")\n@objective(model, Max, y)\noptimize!(model)\nvalue(x), value(y)","category":"page"},{"location":"generated/Extended Formulation/","page":"Extended Formulation","title":"Extended Formulation","text":"In the optimization problem, above, the auxiliary variables of the extended formulation are transparently added inside a bridge. To manipulate the auxiliary variables, one can use the extended H-representation directly instead of its projection. Note that as the auxiliary dimensions have no name, we cannot use variable_by_name to retrieve the corresponding JuMP variables. We can instead catch the returned value of @variable in some variable v in order to use anonymous JuMP variables while still assigning the created JuMP variables to v.","category":"page"},{"location":"generated/Extended Formulation/","page":"Extended Formulation","title":"Extended Formulation","text":"import GLPK\nmodel = Model(GLPK.Optimizer)\nv = @variable(model, [1:12] in diamond.set)\ny = variable_by_name(model, \"y\")\n@objective(model, Max, y)\noptimize!(model)\nvalue.(v)","category":"page"},{"location":"generated/Extended Formulation/","page":"Extended Formulation","title":"Extended Formulation","text":"","category":"page"},{"location":"generated/Extended Formulation/","page":"Extended Formulation","title":"Extended Formulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"redundancy/#Containment/Redundancy","page":"Containment/Redundancy","title":"Containment/Redundancy","text":"","category":"section"},{"location":"redundancy/#Containment","page":"Containment/Redundancy","title":"Containment","text":"","category":"section"},{"location":"redundancy/","page":"Containment/Redundancy","title":"Containment/Redundancy","text":"in\nissubset\nininterior\ninrelativeinterior\nsupport_function","category":"page"},{"location":"redundancy/#Base.in","page":"Containment/Redundancy","title":"Base.in","text":"in(p::VRepElement, h::HRepElement)\n\nReturns whether p is in h. If h is an hyperplane, it returns whether langle a x rangle approx beta. If h is an halfspace, it returns whether langle a x rangle le beta.\n\nin(p::VRepElement, h::HRep)\n\nReturns whether p is in h, e.g. in all the hyperplanes and halfspaces supporting h.\n\n\n\n\n\n","category":"function"},{"location":"redundancy/#Base.issubset","page":"Containment/Redundancy","title":"Base.issubset","text":"issubset(p::Rep, h::HRepElement)\n\nReturns whether p is a subset of h, i.e. whether h supports the polyhedron p.\n\n\n\n\n\n","category":"function"},{"location":"redundancy/#Polyhedra.ininterior","page":"Containment/Redundancy","title":"Polyhedra.ininterior","text":"ininterior(p::VRepElement, h::HRepElement)\n\nReturns whether p is in the interior of h. If h is an hyperplane, it always returns false. If h is an halfspace langle a x rangle leq beta, it returns whether p is in the open halfspace langle a x rangle  beta\n\nininterior(p::VRepElement, h::HRep)\n\nReturns whether p is in the interior of h, e.g. in the interior of all the hyperplanes and halfspaces supporting h.\n\n\n\n\n\n","category":"function"},{"location":"redundancy/#Polyhedra.inrelativeinterior","page":"Containment/Redundancy","title":"Polyhedra.inrelativeinterior","text":"inrelativeinterior(p::VRepElement, h::HRepElement)\n\nReturns whether p is in the relative interior of h. If h is an hyperplane, it is equivalent to p in h since the relative interior of an hyperplane is itself. If h is an halfspace, it is equivalent to ininterior(p, h).\n\ninrelativeinterior(p::VRepElement, h::HRep)\n\nReturns whether p is in the relative interior of h, e.g. in the relative interior of all the hyperplanes and halfspaces supporting h.\n\n\n\n\n\n","category":"function"},{"location":"redundancy/#Polyhedra.support_function","page":"Containment/Redundancy","title":"Polyhedra.support_function","text":"supportfunction(h::AbstractVector, rep::Rep, solver=Polyhedra.linearobjective_solver(p))\n\nReturn the value of the support function of rep at h. See [Section 13, R15] for more details.\n\n[R15] Rockafellar, R.T. Convex analysis. Princeton university press, 2015.\n\n\n\n\n\n","category":"function"},{"location":"redundancy/#Linearity","page":"Containment/Redundancy","title":"Linearity","text":"","category":"section"},{"location":"redundancy/","page":"Containment/Redundancy","title":"Containment/Redundancy","text":"detecthlinearity!\ndetecthlinearity\ndetectvlinearity!\ndetectvlinearity\ndetect_new_linearities\ndim","category":"page"},{"location":"redundancy/#Polyhedra.detecthlinearity!","page":"Containment/Redundancy","title":"Polyhedra.detecthlinearity!","text":"detecthlinearity!(p::HRep; kws...)\n\nDetects all the hyperplanes contained in the H-representation and remove all redundant hyperplanes.\n\nThe remaining keyword arguments kws are passed to detecthlinearity.\n\nExamples\n\nThe representation\n\nh = HalfSpace([1, 1], 1]) ∩ HalfSpace([-1, -1], -1)\n\ncontains the hyperplane HyperPlane([1, 1], 1).\n\n\n\n\n\n","category":"function"},{"location":"redundancy/#Polyhedra.detecthlinearity","page":"Containment/Redundancy","title":"Polyhedra.detecthlinearity","text":"detecthlinearity(hr::HRepresentation, solver; kws...)\n\nReturn a new H-representation with linearity detected using solver.\n\nThe remaining keyword arguments kws are passed to detect_new_linearities.\n\n\n\n\n\n","category":"function"},{"location":"redundancy/#Polyhedra.detectvlinearity!","page":"Containment/Redundancy","title":"Polyhedra.detectvlinearity!","text":"detectvlinearity!(p::VRep, solver=default_solver(p); kws...)\n\nDetects all the lines contained in the V-representation and remove all redundant lines.\n\nThe remaining keyword arguments kws are passed to detectvlinearity.\n\nExamples\n\nThe representation\n\nv = conichull([1, 1], [-1, -1])\n\ncontains the line Line([1, 1]).\n\n\n\n\n\n","category":"function"},{"location":"redundancy/#Polyhedra.detectvlinearity","page":"Containment/Redundancy","title":"Polyhedra.detectvlinearity","text":"detectvlinearity(vr::VRepresentation, solver; kws...)\n\nReturn a new V-representation with linearity detected using solver.\n\nThe remaining keyword arguments kws are passed to detect_new_linearities.\n\n\n\n\n\n","category":"function"},{"location":"redundancy/#Polyhedra.detect_new_linearities","page":"Containment/Redundancy","title":"Polyhedra.detect_new_linearities","text":"detect_new_linearities(rep::HRepresentation{T}, solver; verbose=0, ztol=Base.rtoldefault(T)) where {T}\n\nGiven a polyhedron with H-representation rep, detect whether a new hyperplane can be generated from the halfspaces in halfspaces using an linear program solved by solver. The method is similar to the method used for lines described as follows. This function is automatically called by removehredundancy if a solver is provided.\n\ndetect_new_linearities(rep::VRepresentation{T}, solver; verbose=0, ztol=Base.rtoldefault(T)) where {T}\n\nGiven a cone defined by the V-representation rep (ignoring the points in the representation if any), detect whether a new line can be generated from the rays in rays using an linear program solved by solver. The method is as follows (suppose lines is empty for simplicity). This function is automatically called by removevredundancy if a solver is provided.\n\nThe keyword argument ztol is used as a tolerance to decide whether a number is zero.\n\nIf there was a line l in the cone, it would mean that there exist μ >= 0 and ν >= 0 such that Σ μ_i r_i = l and Σ ν_i r_i = -l. We deduce from this that Σ λ_i r_i = 0 where λ = μ + ν.\n\nConversely, if there are λ >= 0 such that Σ λ_i r_i = 0 then let j be the index of λ with largest magnitude (to make sure it is nonzero). We have Σ_{i != j} λ_i/λ_j r_i = -r_j. As both r_j and -r_j are in the cone, r_j generates a line in the cone. However, this means that we now have Σ_{i != j} λ_i/λ_j r_i ≡ 0 (mod r_j) so if there is another λ_i with nonzero value, we can transform it to a line as well. In summary, we have a line r_i for each i such that λ_i != 0.\n\nThe dual program is:\n\nmax z\ns.t. r_i'x ≥ z\n\nWhen the primal is feasible, the dual program may still be feasible. We know that z = 0 by strong duality as the objective value needs to be equal to the objective of the primal which is zero. So the constraints are r_i'x ≥ 0. If we have r_i'x > 0 for some i, it means that -r_i does not belong to the cone hence r_i can be dropped for the purpose of searching for lines.\n\nNote\n\nIn CDDLib, the dual program is solved, if the objective value is zero then linearity are found by, for each i such that r_i'x = 0, solve an LP to find whether -r_i belongs to the cone. CDDLib ignores the primal results provided in λ which directly gives linearity without the need to solve an LP for each ray. The method implemented in Polyhedra is therefore significantly more efficient as its complexity is O(dimension of linespace) which is upper bounded by O(fulldim) while the method of CDDLib is O(number of rays).\n\n\n\n\n\n","category":"function"},{"location":"redundancy/#Polyhedra.dim","page":"Containment/Redundancy","title":"Polyhedra.dim","text":"dim(h::HRep, current=false)\n\nReturns the dimension of the affine hull of the polyhedron. That is the number of non-redundant hyperplanes that define it. If current is true then it simply returns the dimension according the current number of hyperplanes, assuming that the H-linearity has already been detected. Otherwise, it first calls detecthlinearity!.\n\n\n\n\n\n","category":"function"},{"location":"redundancy/#Duplicates","page":"Containment/Redundancy","title":"Duplicates","text":"","category":"section"},{"location":"redundancy/","page":"Containment/Redundancy","title":"Containment/Redundancy","text":"removeduplicates","category":"page"},{"location":"redundancy/#Polyhedra.removeduplicates","page":"Containment/Redundancy","title":"Polyhedra.removeduplicates","text":"removeduplicates(rep::Representation)\n\nRemoves the duplicates in the Representation.\n\nIn an H-representation, it removes the redundant hyperplanes and it remove an halfspace when it is equal to another halfspace in the affine hull. For instance, HalfSpace([1, 1], 1) is equal to HalfSpace([1, 0], 0) in the affine hull generated by HyperPlane([0, 1], 1]).\nIn a V-representation, it removes the redundant lines and it remove a point (resp. ray) when it is equal to another point (resp. ray) in the line hull. For instance, in the line hull generated by Line([0, 1]), [1, 1] is equal to [1, 0] and Ray([2, 2]) is equal to Ray([1, 0]).\n\n\n\n\n\n","category":"function"},{"location":"redundancy/#Redundancy","page":"Containment/Redundancy","title":"Redundancy","text":"","category":"section"},{"location":"redundancy/","page":"Containment/Redundancy","title":"Containment/Redundancy","text":"Redundancy\nhredundancy\nvredundancy\nisredundant\nremovehredundancy\nremovehredundancy!\nremovevredundancy\nremovevredundancy!","category":"page"},{"location":"redundancy/#Polyhedra.Redundancy","page":"Containment/Redundancy","title":"Polyhedra.Redundancy","text":"@enum Redundancy UNKNOWN_REDUNDANCY LINEARITY_DETECTED NO_REDUNDANCY\n\nRedundancy of a H-representation or V-representation.\n\nUNKNOWN_REDUNDANCY: It is unknown whether there are any undetected linearity or redundancy.\nLINEARITY_DETECTED: There are no undetected linearity.\nNO_REDUNDANCY: There are no undetected linearity not redundancy.\n\nAn undetected linearity for a V-representation is a Line that is implicit in a conic hull of Rays. For instance, conichull([1, 1], [-1, -1]) has undetected linearity because it contains the Line Line([1, 1]). Some undetected linearity is less obvious, e.g., conichull([1, 0, -1], [0, 1, 1], [-1, -1, 0]) contains the Line Line([1, 1, 0]) as the sum of the first two Rays is Ray([1, 1, 0]).\n\nAn undetected linearity for a H-representation is a HyperPlane that is implicit in an intersection of HalfSpaces. For instance, HalfSpace([1, 1], 1) ∩ HalfSpace([-1, -1], 1) has undetected linearity because it contains the HyperPlane HyperPlane([1, 1], 1). Some undetected linearity is less obvious, e.g., HalfSpace([1, 0], -1) ∩ HalfSpace([0, 1], 1) ∩ HalfSpace([-1, -1], 0) contains the HyperPlane HyperPlane([1, 1], 0) as the sum of the first two HalfSpaces is HalfSpace([1, 1], 0).\n\n\n\n\n\n","category":"type"},{"location":"redundancy/#Polyhedra.hredundancy","page":"Containment/Redundancy","title":"Polyhedra.hredundancy","text":"hredundancy(p::Polyhedron)\n\nReturn the Redundancy of hrep(p).\n\n\n\n\n\n","category":"function"},{"location":"redundancy/#Polyhedra.vredundancy","page":"Containment/Redundancy","title":"Polyhedra.vredundancy","text":"vredundancy(p::Polyhedron)\n\nReturn the Redundancy of vrep(p).\n\n\n\n\n\n","category":"function"},{"location":"redundancy/#Polyhedra.isredundant","page":"Containment/Redundancy","title":"Polyhedra.isredundant","text":"isredundant(p::Rep, idx::Index; strongly=false)\n\nReturn a Bool indicating whether the element with index idx can be removed without changing the polyhedron represented by p. If strongly is true,\n\nif idx is an H-representation element h, it returns true only if no V-representation element of p is in the hyperplane of h.\nif idx is a V-representation element v, it returns true only if v is in the relative interior of p.\n\n\n\n\n\n","category":"function"},{"location":"redundancy/#Polyhedra.removehredundancy","page":"Containment/Redundancy","title":"Polyhedra.removehredundancy","text":"removehredundancy(hr::HRepresentation, solver)\n\nReturn a H-representation of the polyhedron represented by hr with all the elements of hr except the redundant ones, i.e. the elements that can be expressed as convex combination of other ones.\n\n\n\n\n\n","category":"function"},{"location":"redundancy/#Polyhedra.removehredundancy!","page":"Containment/Redundancy","title":"Polyhedra.removehredundancy!","text":"removehredundancy!(p::HRep; kws...)\n\nRemoves the elements of the H-representation of p that can be removed without changing the polyhedron represented by p. That is, it only keeps the halfspaces corresponding to facets of the polyhedron.\n\nThe remaining keyword arguments kws are passed to detectvlinearity! and detecthlinearity!.\n\n\n\n\n\n","category":"function"},{"location":"redundancy/#Polyhedra.removevredundancy","page":"Containment/Redundancy","title":"Polyhedra.removevredundancy","text":"removevredundancy(vr::VRepresentation, solver)\n\nReturn a V-representation of the polyhedron represented by vr with all the elements of vr except the redundant ones, i.e. the elements that can be expressed as convex combination of other ones.\n\n\n\n\n\n","category":"function"},{"location":"redundancy/#Polyhedra.removevredundancy!","page":"Containment/Redundancy","title":"Polyhedra.removevredundancy!","text":"removevredundancy!(p::VRep; strongly=false, planar=true, kws...)\n\nRemoves the elements of the V-representation of p that can be removed without changing the polyhedron represented by p. That is, it only keeps the extreme points and rays. This operation is often called \"convex hull\" as the remaining points are the extreme points of the convex hull of the initial set of points. If strongly=true, weakly redundant points, i.e., points that are not extreme but are not in the relative interior either, may be kept. If fulldim(p) is 2, strongly is false and planar is true, a planar convex hull algorithm is used.\n\nThe remaining keyword arguments kws are passed to detectvlinearity! and detecthlinearity!.\n\n\n\n\n\n","category":"function"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"EditURL = \"https://github.com/JuliaPolyhedra/Polyhedra.jl/blob/master/examples/Convex hull and intersection.jl\"","category":"page"},{"location":"generated/Convex hull and intersection/#Convex-hull-and-intersection","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"","category":"section"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/Convex hull and intersection/#Introduction","page":"Convex hull and intersection","title":"Introduction","text":"","category":"section"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"These examples illustrate common operations on polyhedra using Polyhedra.jl:","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"The convex hull of the union of polytopes\nThe intersection of polytopes","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"We start by choosing a polyhedral library that will be used for computing the H-representation from the V-representation and vice-versa as well as removing redundant points. In these example, we use the default library available in Polyhedra but it can be replaced by any other library listed here, e.g. by changing the last two lines below by import CDDLib and lib = CDDLib.Library() to use CDDLib.","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"using Polyhedra\nimport GLPK\nlib = DefaultLibrary{Float64}(GLPK.Optimizer)","category":"page"},{"location":"generated/Convex hull and intersection/#Convex-hull","page":"Convex hull and intersection","title":"Convex hull","text":"","category":"section"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"The binary convex hull operation between two polyhedra is obtained with the convexhull function.","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"Below we compute the convex hull of the union of two polygons from their V-representation.","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"P1 = polyhedron(vrep([\n    -1.9 -1.7\n    -1.8  0.5\n     1.7  0.7\n     1.9 -0.3\n     0.9 -1.1\n]), lib)\n\nP2 = polyhedron(vrep([\n    -2.5 -1.1\n    -0.8  0.8\n     0.1  0.9\n     1.8 -1.2\n     1.3  0.1\n]), lib)\n\nPch = convexhull(P1, P2)","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"Note that the convex hull operation is done in the V-representation so no representation conversion is needed for this operation since P1 and P2 where constructed from their V-representation:","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"hrepiscomputed(P1), hrepiscomputed(P2), hrepiscomputed(Pch)","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"Let us note that the convexhull of a V-representation contains points and rays and represents the convex hull of the points together with the conic hull of the rays. So, convexhull(P1, P2) does the union of the vertices:","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"npoints(Pch)","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"However, if we want to remove the redundant points we can use removevredundancy!:","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"removevredundancy!(Pch)\nnpoints(Pch)","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"We can plot the polygons and the convex hull of their union using the plot function. For further plotting options see the Plots.jl documentation. We can see below the 8 redundant points highlighted with green dots, the two points that are not highlighted are the redundant ones.","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"using Plots\nplot(P1, color=\"blue\", alpha=0.2)\nplot!(P2, color=\"red\", alpha=0.2)\nplot!(Pch, color=\"green\", alpha=0.1)\nscatter!(Pch, color=\"green\")","category":"page"},{"location":"generated/Convex hull and intersection/#Intersection","page":"Convex hull and intersection","title":"Intersection","text":"","category":"section"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"Intersection of polyhedra is obtained with the intersect function.","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"Below we compute the intersection of the two polygons from the previous example.","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"Pint = intersect(P1, P2)","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"While P1 and P2 have been constructed from their V-representation, their H-representation has been computed to build the intersection Pint.","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"hrepiscomputed(P1), vrepiscomputed(P1), hrepiscomputed(P2), vrepiscomputed(P2)","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"On the other hand, Pint is constructed from its H-representation hence its V-representation has not been computed yet.","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"hrepiscomputed(Pint), vrepiscomputed(Pint)","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"We can obtain the number of points in the intersection with npoints as follows:","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"npoints(Pint)","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"Note that this triggers the computation of the V-representation:","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"hrepiscomputed(Pint), vrepiscomputed(Pint)","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"We can plot the polygons and their intersection using the plot function.","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"using Plots\nplot(P1, color=\"blue\", alpha=0.2)\nplot!(P2, color=\"red\", alpha=0.2)\nplot!(Pint, color=\"yellow\", alpha=0.6)","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"","category":"page"},{"location":"generated/Convex hull and intersection/","page":"Convex hull and intersection","title":"Convex hull and intersection","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Polyhedra-–-Manipulation-of-Polyhedra-in-Julia","page":"Index","title":"Polyhedra –- Manipulation of Polyhedra in Julia","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Polyhedra is a package for polyhedra manipulations in Julia. It provides an unified interface for Polyhedra Manipulation Libraries such as CDDLib.jl, LRSLib.jl and QHull.","category":"page"},{"location":"","page":"Index","title":"Index","text":"Polyhedra can either be represented by a set of linear inequalities or by vertices and rays. In the first case, the points of the polyhedron are the points that satisfies all the inequalities and in the second case they are the points that can be expressed as a convex combination of the vertices plus a conic combination of the rays. The manipulations that Polyhedra can perform include","category":"page"},{"location":"","page":"Index","title":"Index","text":"Projection: Projection of a polyhedron on a lower dimensional space, e.g. Fourier-Motzkin elimination.\nChanging the Representation\nVertex enumeration problem: Computing the extremal vertices and rays from an inequality representation\nConvex hull problem: Computing a set of linear inequalities describing the polyhedron from a vertex/ray representation\nRemoval of redundant inequalities or redundant vertices/rays.\nPlotting of 2D polyhedra using Plots\nDecomposition of 3D polyhedra into vertices and triangular faces, enabling easy visualization of 3D polyhedra using DrakeVisualizer or GLVisualize.","category":"page"},{"location":"","page":"Index","title":"Index","text":"Depending on the library, these manipulation can either be in floating point or exact rational arithmetic.","category":"page"},{"location":"","page":"Index","title":"Index","text":"Each operation has a default fallback implementation which is used in case the library does not support it. Polyhedra also includes a default library which does not implement anything, hence using every fallback.","category":"page"},{"location":"","page":"Index","title":"Index","text":"Polyhedra remains under active development, and we welcome your feedback, suggestions, and bug reports.","category":"page"},{"location":"#Installing-Polyhedra","page":"Index","title":"Installing Polyhedra","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"If you are familiar with Julia you can get started quickly by using the package manager to install Polyhedra","category":"page"},{"location":"","page":"Index","title":"Index","text":"julia> Pkg.add(\"Polyhedra\")","category":"page"},{"location":"","page":"Index","title":"Index","text":"And a Polyhedra Manipulation Library, e.g.","category":"page"},{"location":"","page":"Index","title":"Index","text":"julia> Pkg.add(\"CDDLib\")","category":"page"},{"location":"#Contents","page":"Index","title":"Contents","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Pages = [\"installation.md\", \"representation.md\", \"polyhedron.md\", \"plot.md\", \"redundancy.md\", \"projection.md\", \"optimization.md\", \"utilities.md\"]\nDepth = 2","category":"page"}]
}
